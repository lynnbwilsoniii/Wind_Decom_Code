	SUBROUTINE MAKEFILE(CH)

C	A PROGRAM TO SEARCH FOR LANGMUIR WAVES IN THE EARTH'S TAIL 
C		IN TDSF OR FILL.
C
C	RESULTS ARE WRITTEN TO MAKEFILE18.RESULTS
C
C	    THIS IS MAKEFILE18.  ORIGINALLY IT ONLY DID CHANNEL 1,
C	    THAT VERSION IS STORED AS .OLDOK.  
C
	COMMON /TDSF_BACKGROUND/ TDSFBCK(1025,2,4),NBCK(2,4)
	COMMON /HISTBLK/ HIST(14,2,100),FHIST(14),NHISTST,HISTINT
	COMMON /XFER/ SPHASE(1025)
	INTEGER*4 FHIST
	integer*4 ch,ok,okt,OK1,OK2,SCETI4(2),N1DATA(2048),N2DATA(2048)
	INTEGER*4 W_CHANNEL_CLOSE,W_EVENT,RET_SIZE,W_MESSAGES_OFF
	INTEGER*4 W_ITEM_I4,W_ITEM_R4,W_ITEM_R8
	INTEGER*4 TDS_CHANNEL,ISRC,SUNCLOCK,LIMSPS(4),FLLIMS(4)
	INTEGER*4 FUPLIM,FLLIM,FUPNEW,FLLNEW
	REAL*8 SCET8,XGSM,YGSM,ZGSM,RGSM
	REAL DBSPEC1(1025),V1DATA(2048),PHASE1(1025)
	REAL DBSPEC2(1025),V2DATA(2048),PHASE2(1025)
	REAL ZCROSS(1024),Z1INT(1024),Z2INT(1024),RESOL(4)
	REAL FREQ(1024),FCOUNT(2),FAVR(2),FSTD(2),F3MOM(2),FBW(2),SKEW(2)
	character*32 ITEM
	character*4 event
	DATA TWOPI /6.2831853/
	DATA YXRATIO /11.8/
	DATA RE /6378./
	DATA LIMSPS /3,5,20,20/
	DATA FLLIMS /4,12,42,80/
C	ABOVE BASED ON LEFFX = 41.1, LEFFY = 3.79
	EFFLENX = 41.1
	EFFLENY = 3.79
	DATA RESOL /118.,30.,8.,2./
c	data event /'TDSF'/
	data event /'FILL'/
C
	IFOUND = 0
 100	ok = w_event(ch,event)
C
C	CHECK FOR END OF RECORD
C
	if (ok.ne.1) then
		if(ok.eq.82) then
		   ok = w_channel_close(ch)
		   return
	        endif
		write(6,*) 'cannot open ',event, ', ok=', ok
	endif
C
C	END OF END OF RECORD CHECK
C
	OKT = W_MESSAGES_OFF(ch)
C
C
	ITEM = 'CHANNEL'
	ok = W_ITEM_I4(ch, item, TDS_CHANNEL, 1, ret_size)
C
	IPROS = 4
	IF(TDS_CHANNEL.EQ.1) THEN
C	  ITEM = 'DATA'
C	  ok1 = W_ITEM_I4(ch, item, N1DATA, 2048, ret_size)
	  CALL TDS_PHYS(CH,IPROS,N1DATA,V1DATA,DBSPEC1)
	  DO N = 1,1024
	    PHASE1(N) = SPHASE(N)
	  ENDDO
	  ITEM = 'EVENT_NUMBER'
	  ok = W_ITEM_I4(ch, item, NO_EVT1, 1, ret_size)
	  GO TO 100
	ELSEIF(TDS_CHANNEL.EQ.2) THEN
	  ITEM = 'DATA'
	  ok2 = W_ITEM_I4(ch, item, N2DATA, 2048, ret_size)
	  CALL TDS_PHYS(CH,IPROS,N2DATA,V2DATA,DBSPEC2)
	  DO N = 1,1024
	    PHASE2(N) = SPHASE(N)
	  ENDDO
	  ITEM = 'EVENT_NUMBER'
	  ok = W_ITEM_I4(ch, item, NO_EVT, 1, ret_size)
	  IF(NO_EVT.NE.NO_EVT1) THEN
	    PRINT*,'EVENTS DONT MATCH',NO_EVT,NO_EVT1
	    GO TO 100
	  ENDIF
	ELSE
	  GO TO 100
	ENDIF

C
CDIAG	PRINT*,'******START EVENT',NO_EVT1,NO_EVT,' *****'
	PRINT*,'******START EVENT',NO_EVT1,NO_EVT,' *****'
C
C	MOST OF THE EVENTS ARE BLOBS.  TO ELIMINATE THEM:
C	BLOBS START NEAR THE MIDDLE, AND MOSTLY OCCUPY THE
C	SECOND HALF OF AN EVENT.  SO REQUIRE THAT THE MAXIMUM
C	INTERVAL BETWEEN ZEROS IN THE SECOND HALF NOT BE 
C	MORE THAN ?? TIMES THE AVERAGE INTERVAL IN THE FIRST
C	HALF
C
C	THERE ARE ALSO SPIKES.  TO ELIMINATE THEM, CALCULATE THE
C	NUMBER OF POINTS WHICH ARE LARGER THAN HALF THE PEAK.
c	IF(TDS_CHANNEL.EQ.1) GO TO 100		! GO GET CHANNEL 2
c	IF(TDS_CHANNEL.NE.2) GO TO 100
C
C
c********** histogram of low freq powers
C
C	IHIST = 1
	IHIST = 0
	IF(IHIST.NE.1) GO TO 175
	ITEM = 'FAST_RX_SPEED'
	ok = W_ITEM_I4(ch, item, ISPS, 1, ret_size)
	IF(ISPS.NE.0) GO TO 100
C
	histint = 1.
	nhistst = -125
C		STORAGE HAS TO BE NHIST = 1 TO 100.  NHISTST SETS
C		THE SMALLEST SIGNAL IN DB
	do irx = 1,2
	  do ifri = 1,14
	    ifr = ifri
	    fhist(ifri) = ifr
	    if(irx.eq.1) then
	      nhist = dbspec1(ifr+1)
	    else
 	      nhist = dbspec2(ifr+1)
	    endif
C		range is NHISTST TO NHISTST+99
	    nhist = nhist - nhistst + 1
	    nhist = max0(nhist,1)
	    nhist = min0(nhist,100)
	    hist(ifri,irx,nhist) = hist(ifri,irx,nhist) + 1.
          enddo
	enddo
	if(dbspec1(2).gt.-40.) write (72,*) no_evt1,dbspec1(2)
	IF(IHIST.EQ.1) GO TO 100
 175	CONTINUE
C
c********** end histogram
C
	ITEM = 'WIND_ORBIT_X(GSE)_R8'
	ok = W_ITEM_R8(ch, item, XGSM, 1, ret_size)
	ITEM = 'WIND_ORBIT_Y(GSE)_R8'
	ok = W_ITEM_R8(ch, item, YGSM, 1, ret_size)
	ITEM = 'WIND_ORBIT_Z(GSE)_R8'
	ok = W_ITEM_R8(ch, item, ZGSM, 1, ret_size)
C	ITEM = 'WIND_ORBIT_X(GSM)_R8'
C	ok = W_ITEM_R8(ch, item, XGSM, 1, ret_size)
C	ITEM = 'WIND_ORBIT_Y(GSM)_R8'
C	ok = W_ITEM_R8(ch, item, YGSM, 1, ret_size)
C	ITEM = 'WIND_ORBIT_Z(GSM)_R8'
C	ok = W_ITEM_R8(ch, item, ZGSM, 1, ret_size)
C	NOTE THAT IT'S REALLY GSE
	RGSM = DSQRT(XGSM**2+YGSM**2+ZGSM**2)
	XRE = XGSM/RE
	YRE = YGSM/RE
	ZRE = ZGSM/RE
	RRE = RGSM/RE
	IF(XRE.GT.0.) GO TO 100		! TAIL REGION ONLY
C
	XMAX = 0.
	YMAX = 0.
	XMIN = 0.
	YMIN = 0.
	DO N = 1,2048
	  XMAX = AMAX1(XMAX,V1DATA(N))
	  YMAX = AMAX1(YMAX,V2DATA(N))
	  XMIN = AMIN1(XMIN,V1DATA(N))
	  YMIN = AMIN1(YMIN,V2DATA(N))
	ENDDO
C****
	XMAX = AMAX1(XMAX,-XMIN)
	YMAX = AMAX1(YMAX,-YMIN)
C****
C	CHANGE TO mV/m
	XMAX = 1000.*XMAX/41.1
	YMAX = 1000.*YMAX/3.79
	EMAX = SQRT(XMAX**2+YMAX**2)
C
C	XCOUNT = 0.
C	YCOUNT = 0.
C	DO N = 1,2048
C	  IF(ABS(V1DATA(N)).GT.XMAX) XCOUNT = XCOUNT + 1.
C	  IF(ABS(V2DATA(N)).GT.YMAX) YCOUNT = YCOUNT + 1.
C	ENDDO
C
C	DO N = 1,2048
C	  N1DATA(N) = N1DATA(N) - 128
C	  N2DATA(N) = N2DATA(N) - 128
C	ENDDO
C
C	FIND ZERO CROSSINGS
C
C	IZCNT = 1
	IZCNT = 0
C	ZCROSS(IZCNT) = 0.
	IL = 1
	IZ = IL
C	  IF(N1DATA(IL).EQ.0) PRINT*,'ZERO DATA',IL,N1DATA(IL),N1DATA(IL+1)
C
C	CENTER PART OF CHANNEL 1
C
	DO IL = 512,1536
C
C	    IF(N1DATA(IL).EQ.0) PRINT*,'ZERO DATA',IL,N1DATA(IL-1),
C     1     N1DATA(IL),N1DATA(IL+1)
C
C		COUNT ONLY POS TO NEG
C
	    IF(V1DATA(IL).GT.0.AND.V1DATA(IL+1).LE.0) THEN
	        IZCNT = IZCNT+1
		S1 = V1DATA(IL)
		S2 = V1DATA(IL+1)
		IF(S1-S2.NE.0.) THEN
	  	   ZCROSS(IZCNT) = IL + S1/(S1-S2)
	  	ELSE
		   ZCROSS(IZCNT) = IL 
		ENDIF	
	    ENDIF
	ENDDO
C
C	I AM PRETTY SURE THAT I AM GETTING MULTIPLE CROSSINGS AT WHAT IS 
C	SUPPOSED TO BE A SINGLE CROSSING, DUE TO THE CHARACTERISTICS OF THE 
C	A/D CONVERTER
C
	IZCNT1 = IZCNT
	ZCNT1 = IZCNT
C	PRINT*,'ZERO CROSSINGS',NO_EVT,NO_EVT1,IZCNT
C
C
	Z1MAX = 0.
	Z1MIN = 2048.
	DO N = 1,IZCNT-1
	  Z1INT(N) = ZCROSS(N+1) - ZCROSS(N)
	  Z1MAX = AMAX1(Z1INT(N),Z1MAX)
	  IF(Z1INT(N).EQ.0.) PRINT*,'ZINT=0 AT ',N
	  IF(Z1INT(N).EQ.0.) Z1INT(N) = 1.E-6
	  z1min = amin1(z1int(n),z1min)
	ENDDO
C
C	SINCE I AM LOOKING FOR NEARLY MONOCHROMATIC WAVES, I THINK,
C		REMOVE SHORT INTERVALS WHICH MAY JUST BE APPARENT
C		MULTIPLE CROSSINGS DUE TO HARDWARE SIGN TEST AND OFFSET
C		NOT DONE YET
C
	IF(IZCNT.GE.2) AVRINT = (ZCROSS(IZCNT)-ZCROSS(1))/(IZCNT-1)
C	print*,'z1max,z1min,avrint',z1max,z1min,avrint
C
C	  GO TO 100
C
C	FIRST HALF OF CHANNEL 2
C
C	IZCNT = 1
C	ZCROSS(IZCNT) = 1.
C
C	DO IL = 1,1023
C
C		COUNT ONLY POS TO NEG
C
C	  IF(N2DATA(IL).GT.0.AND.N2DATA(IL+1).LE.0) THEN
C	        IZCNT = IZCNT+1
C		S1 = N2DATA(IL)
C		S2 = N2DATA(IL+1)
C		IF(S1-S2.NE.0.) THEN
C	  	   ZCROSS(IZCNT) = IL + S1/(S1-S2)
C	  	ELSE
C		   ZCROSS(IZCNT) = IL 
C		ENDIF	
C	  ENDIF
C	ENDDO
C
C	AVR2_1ST_HALF = 1023./IZCNT
C	NZCNT2 = IZCNT
C
C
C	Z2MAX = 0.
C	DO N = NZCNT2,IZCNT-1
C	  Z2INT(N) = ZCROSS(N+1) - ZCROSS(N)
c	  Z2MAX = AMAX1(Z2INT(N),Z2MAX)
C	  if(z2int(n).gt.z2max) then
C	     z2max = z2int(n)
C	     nnmax = n
C	  endif
C	  IF(Z2INT(N).EQ.0.) PRINT*,'ZINT=0 AT ',N
C	  IF(Z2INT(N).EQ.0.) Z2INT(N) = 1.E-6
C	ENDDO
C	print*,'max int ch 2',z2max,' at',zcross(nnmax),zcross(nnmax+1)
CDIAG	print*,'zero crossings, ch 2,AVR2_1ST_HALF,Z2MAX',NO_EVT,izcnt,
CDIAG     1		AVR2_1ST_HALF,Z2MAX
C	IF(Z2MAX.GT.5.*AVR2_1ST_HALF.AND.Z2MAX.GT.220.) THEN
C	  PRINT*,NO_EVT,' CH 2 BLOB',AVR2_1ST_HALF,Z2MAX
C	  ITEM = 'SUN_ANGLE'
C	  ok = W_ITEM_I4(ch, item, SUNCLOCK, 1, ret_size)
C	  write(52,*) no_evt,avr2_1st_half,z2max,sunclock
C	  IFOUND = 0
C	  GO TO 100
C	ENDIF
C
C	ZCNT2 = IZCNT
C
C	I FOUND THAT THERE ARE BLOBS AT RANDOM IN CHANNEL 2, PRESUMABLE
C	BECAUSE THE TRIGGER, FROM CHANNEL 1, SOMETIMES CATCHES
C	ONE AT RANDOM.  SO TEST FOR THESE
C
c	AVR2_ALL = 2047./IZCNT
	Z3MAX = 0.
	DO N = 1,IZCNT-1
	  Z2INT(N) = ZCROSS(N+1) - ZCROSS(N)
	  if(z2int(n).gt.z3max) then
	     z3max = z2int(n)
	     nnmax = n
	  endif
	ENDDO
c	PRINT*,'TEST 3',NO_EVT,AVR2_ALL,Z3MAX,NNMAX
C
C	IF(Z3MAX.GT.5.*AVR2_ALL.OR.Z3MAX.GT.220.) THEN
C	  PRINT*,NO_EVT,' CH 2 RANDOM BLOB',AVR2_1ST_HALF,Z3MAX
C	  ITEM = 'SUN_ANGLE'
C	  ok = W_ITEM_I4(ch, item, SUNCLOCK, 1, ret_size)
C	  write(53,*) no_evt,avr2_all,z3max,sunclock,nnmax
C	  IFOUND = 0
C	  GO TO 100
C	ENDIF
C
	ITEM = 'SOURCE'
	ok = W_ITEM_I4(ch, item, ISRC, 1, ret_size)
	ITEM = 'EVENT_NUMBER'
	ok = W_ITEM_I4(ch, item, NO_EVT, 1, ret_size)
	ITEM = 'EVENT_SCET'
	ok = W_ITEM_I4(ch, item, SCETI4, 2, ret_size)
	ITEM = 'FAST_RX_SPEED_R4'
	ok = W_ITEM_R4(ch, item, SPS, 1, ret_size)
	ITEM = 'FAST_RX_SPEED'
	ok = W_ITEM_I4(ch, item, ISPS, 1, ret_size)
	ITEM = 'WIND_MFI_BPHI(GSE)_R4'
	ok = W_ITEM_R4(ch, item, BANGLE, 1, ret_size)
	ITEM = 'MAG_ELEVATION'
	ok = W_ITEM_I4(ch, item, MAGEL, 1, ret_size)
	ITEM = 'SUN_ANGLE'
	ok = W_ITEM_I4(ch, item, SUNCLOCK, 1, ret_size)
C	ITEM = 'WIND_3DP_E_TEMP_R4'
C	ok = W_ITEM_R4(ch, item, TEMPE, 1, ret_size)
C	ITEM = 'WIND_3DP_ION_TEMP_R4'
C	ok = W_ITEM_R4(ch, item, TEMPI, 1, ret_size)
	ITEM = 'WIND_3DP_ION_DENSITY_R4'
	ok = W_ITEM_R4(ch, item, DENS_3DP, 1, ret_size)
	ITEM = 'WIND_SWE_DENSITY_R4'
	ok = W_ITEM_R4(ch, item, DENS_SWE, 1, ret_size)
C	ITEM = 'WIND_3DP_ION_VX(GSE)_R4'
C	ok = W_ITEM_R4(ch, item, VX, 1, ret_size)
C	ITEM = 'WIND_3DP_ION_VY(GSE)_R4'
C	ok = W_ITEM_R4(ch, item, VY, 1, ret_size)
	ITEM = 'WIND_MFI_BMAG_R4'
	ok = W_ITEM_R4(ch, item, BMAG, 1, ret_size)
	ITEM = 'WIND_SPIN_RATE_R4'
	ok = W_ITEM_R4(ch, item, SPINRATE, 1, ret_size)
	if(ok.ne.1) then
	  spinrate = 2.
	endif
C
C	CALCULATE FREQUENCY FROM ZERO CROSSINGS
C
	AVRPER = 1.E-6
	IF(IZCNT1.GT.1) AVRPER = (ZCROSS(IZCNT1)-ZCROSS(1))/SPS/(ZCNT1-1.)
	FREQHZ = 1./AVRPER
C
C	CALCULATE BANDWIDTH FROM ZERO CROSSING INTERVALS
C
	AVR = 0.
	STD = 0.
	COUNT = 1.E-9
	DO N = 1,IZCNT-1
	  COUNT = COUNT + 1.
	  AVR = AVR + Z1INT(N)  
	  STD = STD + Z1INT(N)**2
	ENDDO
	ZCBW = 0.
	IF(IZCNT.GT.1) THEN
	  AVR = AVR/COUNT
	  STD = STD/COUNT - AVR**2
	  STD = SQRT(AMAX1(STD,0.))
	  ZCBW = STD/AVR
	ENDIF
C
C	CALCULATE FREQUENCIES FOR SPECTRUM
C
	DO N = 1,1024
	  FREQ(N) = (N-1)*SPS/2048.    ! FREQ(N) GOES WITH DBSPECT(N)
	ENDDO
C
C	CALCULATE BANDWIDTH, ETC.
C
	FLLIM = FLLIMS(ISPS+1)
	FUPLIM = 205			! 12 KHZ AT 120 KSPS
	IF(ISPS.NE.0) FUPLIM = 1024
	PRINT*,'ISPS,DO FREQS',ISPS,FREQ(FLLIM),FREQ(FUPLIM)
	NFMAX = 0
	SPMAX = -1000.
	NC = 1
	DO NC = 1,2
	  FCOUNT(NC) = 1.E-20
	  FAVR(NC) = 0.
	  FSTD(NC) = 0.
	  F3MOM(NC) = 0.
	  DO N = FLLIM,FUPLIM
	    IF(NC.EQ.1) THEN
		VLT = 10.**(.1*DBSPEC1(N))
		IF(DBSPEC1(N).GT.SPMAX) THEN
		  SPMAX = DBSPEC1(N)
		  NFMAX1 = N
		  NFMAX = N
	        ENDIF
	    ELSE
		VLT = 10.**(.1*DBSPEC2(N))
	    ENDIF
	    FCOUNT(NC) = FCOUNT(NC) + VLT
	    FAVR(NC) = FAVR(NC) + VLT*FREQ(N)
	    FSTD(NC) = FSTD(NC) + VLT*FREQ(N)**2
	    F3MOM(NC) = F3MOM(NC) + VLT*FREQ(N)**3
	  ENDDO
	  FAVR(NC) = FAVR(NC)/FCOUNT(NC)
	  FSTD(NC) = FSTD(NC)/FCOUNT(NC) - FAVR(NC)**2
	  FBW(NC) = SQRT(AMAX1(FSTD(NC),0.))
	  SKEW(NC) = F3MOM(NC)/FCOUNT(NC) - 3.*FAVR(NC)*FSTD(NC)
     1		 - FAVR(NC)**3
	ENDDO
c	print*,'1st try',nfmax,nc,favr(nc),fbw(nc)
C
C	NOW REDO WITH A MORE LIMITED RANGE
C
C	X BACKGROUND IS TAKEN AS -110 DB IN V^2/HZ, Y S -115
C		SO 7.7E-8 V/M ROOT HZ FOR X, 4.7E-7 FOR Y
	XBACK = 10.**(-110./20.)/EFFLENX
	YBACK = 10.**(-115./20.)/EFFLENY
C  
c	this was absurd
C	IF(XMAX.GE.YMAX) THEN
C	    WIDTH = FBW(1)*EMAX/XBACK 
C	    NBW = WIDTH*2048./SPS
C	ELSE
C	    WIDTH = FBW(2)*EMAX/YBACK 
C	    NBW = WIDTH*2048./SPS
C	ENDIF	
C	NBW = MAX0(NBW,2)
C	FLLNEW = NFMAX - NBW
	FLLNEW = 3*NFMAX/4
	FLLNEW = MAX0(FLLNEW,FLLIM)
	FUPNEW = 5*NFMAX/4
C	FUPNEW = NFMAX + NBW
	FUPNEW = MIN0(FUPNEW,FUPLIM)
C
	DO NC = 1,2
	  FCOUNT(NC) = 1.E-20
	  FAVR(NC) = 0.
	  FSTD(NC) = 0.
	  F3MOM(NC) = 0.
	  DO N = FLLNEW,FUPNEW
	    IF(NC.EQ.1) THEN
		VLT = 10.**(.1*DBSPEC1(N))
	    ELSE
		VLT = 10.**(.1*DBSPEC2(N))
	    ENDIF
	    FCOUNT(NC) = FCOUNT(NC) + VLT
	    FAVR(NC) = FAVR(NC) + VLT*FREQ(N)
	    FSTD(NC) = FSTD(NC) + VLT*FREQ(N)**2
	    F3MOM(NC) = F3MOM(NC) + VLT*FREQ(N)**3
	  ENDDO
	  FAVR(NC) = FAVR(NC)/FCOUNT(NC)
	  FSTD(NC) = FSTD(NC)/FCOUNT(NC) - FAVR(NC)**2
	  FBW(NC) = SQRT(AMAX1(FSTD(NC),0.))
	  SKEW(NC) = F3MOM(NC)/FCOUNT(NC) - 3.*FAVR(NC)*FSTD(NC)
     1		 - FAVR(NC)**3
	  FRBW = FBW(1)/FAVR(1)
c	print*,'2nd try',nfmax,nc,favr(nc),fbw(nc),frbw
	ENDDO
C
C	DETERMINE ANGLE TO B
C
	CALL FITSLOPE(V1DATA,V2DATA,2048,SLOPE,RATIO,SUMSQ)
C	XANG = ATAND(SLOPE*EFFLENX/EFFLENY
	XANG = ATAND(SLOPE)
	END_ANGLE =  -360.*(SUNCLOCK-14.)/4096. - 45. ! ANGLE SUN TO +EX AT END
	IF(END_ANGLE.LT.-180.) END_ANGLE = END_ANGLE + 360.
	IF(END_ANGLE.GT.180.)  END_ANGLE = END_ANGLE - 360.
	DANG = SPINRATE*360./SPS/TWOPI
	ST_ANGLE = END_ANGLE + 3072.*DANG   ! ANGLE SUN TO +EX AT START 16nov99
	END_ANGLE = END_ANGLE + 1024.*DANG
c	ST_ANGLE = END_ANGLE + 2048.*DANG	  ! ANGLE SUN TO +EX AT START
C
	NAVR = 1024
	CTR_ANGLE = ST_ANGLE - NAVR*DANG  !ANGLE SUN TO +EX AT CENTER,nov 1999
	PANGLE = CTR_ANGLE - BANGLE - XANG
	IF(PANGLE.GT.90.)  PANGLE = PANGLE - 180.
	IF(PANGLE.LT.-90.) PANGLE = PANGLE + 180.
	IF(PANGLE.GT.90.)  PANGLE = PANGLE - 180.
	IF(PANGLE.LT.-90.) PANGLE = PANGLE + 180.
	IF(PANGLE.GT.90.)  PANGLE = PANGLE - 180.
	IF(PANGLE.LT.-90.) PANGLE = PANGLE + 180.
	IF(PANGLE.GT.90.)  PANGLE = PANGLE - 180.
	IF(PANGLE.LT.-90.) PANGLE = PANGLE + 180.
	PANGLE = ABS(PANGLE)
C	XBVEC = .2*XMAX*COSD(PANGLE)
C	YBVEC = .2*XMAX*SIND(PANGLE)
C
C	PANGLE IS THE ANGLE BETWEEN THE MAJOR AXIS OF E, AND B
C	print*,'NO_EVT,bangle,ctr_angle',NO_EVT,bangle,ctr_angle
c	print*,'slope,angle to x,angle to b',slope,XANG,PANGLE
C
C	ADD TO BACKGROUND
C
	IBCKG = 0
	IF(IBCKG.NE.0) THEN
	  XMXLIM = .1
	  IF(XMAX.LT.XMXLIM.AND.TDS_CHANNEL.LE.2) THEN
	    DO N = 1,1025
	      TDSFBCK(N,TDS_CHANNEL,ISPS+1) =
     1      TDSFBCK(N,TDS_CHANNEL,ISPS+1) + DBSPEC1(N)
	    ENDDO
	    NBCK(TDS_CHANNEL,ISPS+1) = NBCK(TDS_CHANNEL,ISPS+1) +1
	  ENDIF
	ENDIF
C
C	CRITERIA FOR VALID LANGMUIR WAVES GO HERE
C
	print*,'fp_3dp',fp_3dp
c********
c	if(no_evt.eq.1283701) then
C
c	  BWAVR = .5*(FBW(1)+FBW(2))
c	  XYPH = PHASE1(NFMAX) - PHASE2(NFMAX)
c	  IF(XYPH.GT.180.) XYPH = XYPH - 360.
c	  IF(XYPH.LT.-180.) XYPH = XYPH + 360.
c	WRITE(56,1111) SCETI4,NO_EVT,EVENT(1:1),ISPS,IZCNT,FREQHZ,FAVR(1),
c     1	 FREQ(NFMAX),BWAVR,FRBW,FP_3DP,EMAX,XRE,YRE,ZRE,XYPH,PANGLE,
c     2	 RATIO
c	endif
c********
C	IF(FAVR(1).GT.6.E3) GO TO 100
	IF(IZCNT.LT.LIMSPS(ISPS+1)) GO TO 100
	FP_3DP = 2.E4
	IF(DENS_3DP.GT.0.) FP_3DP = 9.E3*SQRT(DENS_3DP)	  ! PLASMA FREQ IN HZ
	IF(DENS_SWE.GT.0.) FP_SWE = 9.E3*SQRT(DENS_SWE)	  ! PLASMA FREQ IN HZ
c	IF(FP_3DP.GT.7.E3.AND.FP_SWE.GT.7.E3) GO TO 100
C
C	REQUIRE FREQ GT FP_3DP 
C
	IF(FAVR(1).LT.FP_3DP) GO TO 100
C
C	REQUIRE NARROW BANDWIDTH
C
c	print*,'frbw',frbw
	print*,'bwtest',no_evt,fbw(1),fbw(2),resol(isps+1)	
	BWLIM = AMAX1(.05*FAVR(1),RESOL(ISPS+1))  ! maR 14
C	BWLIM = RESOL(ISPS+1)		! MARCH 16
C	IF(FRBW.GT..1) GO TO 100
	IF(FBW(1).GT.BWLIM.OR.FBW(2).GT.BWLIM) GO TO 100
C
	BWAVR = .5*(FBW(1)+FBW(2))
	XYPH = PHASE1(NFMAX) - PHASE2(NFMAX)
	IF(XYPH.GT.180.) XYPH = XYPH - 360.
	IF(XYPH.LT.-180.) XYPH = XYPH + 360.
	WRITE(56,1111) SCETI4,NO_EVT,EVENT(1:1),ISPS,IZCNT,FREQHZ,FAVR(1),
     1	 FREQ(NFMAX),BWAVR,FRBW,FP_3DP,EMAX,XRE,YRE,ZRE,XYPH,PANGLE,
     2	 RATIO
C	1111 IS NOW 114 CHARACTERS
 1111	FORMAT(I10,I8,I10,A2,I2,I4,3F7.0,F7.2,F6.3,F7.0,F6.1,3F7.1,2F7.1
     1		,F6.3)
C
	OK = W_EVENT(CH,'HK')
	ITEM = 'APM_X_PEAK'
	ok = W_ITEM_I4(ch, item, JTEMP, 1, ret_size)
	XPK = APMCAL(1,JTEMP)
	ITEM = 'APM_X_DC'
	ok = W_ITEM_I4(ch, item, JTEMP, 1, ret_size)
	XAVR = APMCAL(2,JTEMP)
	ITEM = 'APM_Y_PEAK'
	ok = W_ITEM_I4(ch, item, JTEMP, 1, ret_size)
	YPK = APMCAL(3,JTEMP)
	ITEM = 'APM_Y_DC'
	ok = W_ITEM_I4(ch, item, JTEMP, 1, ret_size)
	YAVR = APMCAL(4,JTEMP)
	ITEM = 'APM_Z_DC'
	ok = W_ITEM_I4(ch, item, JTEMP, 1, ret_size)
	ZAVR = APMCAL(5,JTEMP)
	WRITE(57,1057) SCETI4,NO_EVT,ISPS,FREQHZ,BWAVR,XPK,XAVR,YPK,YAVR,ZAVR
 1057	FORMAT(I10,I8,I10,I2,F8.0,F7.1,5F7.2)
C
C	FCE = .028*BMAG
C	BETA = .402*(TEMPE+TEMPI)/BMAG**2
C
	IF(OK.NE.82) GO TO 100
C
	return
	end
	SUBROUTINE FITSLOPE(X,Y,N,SLOPE,RATIO,SUMSQ)
C
	DIMENSION X(1),Y(1),WT(2048)
	DATA EFFLENX,EFFLENY /41.1, 3.79/
C
C	LEAST SQUARES FIT   (EY - SLOPE * EX)**2
C
	SUMSQ = 0.
	SXX = 0.
	SXY = 0.
	SYY = 0.	
	DO J = 1,N
C	  WT(J) = .06 + SQRT(ABS(X(J)*Y(J)))
	  WT(J) = 1.
C	  IF(WT(J).NE.0.) THEN
C	    SXX =SXX + X(J)**2/WT(J)
	    SXX =SXX + (X(J)/EFFLENX)**2
	    SXY =SXY + X(J)*Y(J)/EFFLENX/EFFLENY
	    SYY =SYY + (Y(J)/EFFLENY)**2
C	  ENDIF
	ENDDO
C	SLOPE IS Y/X
	IF(SXX.NE.0.) SLOPE = SXY/SXX
	SUMSQ = SXX*SLOPE**2 - 2.*SLOPE*SXY + SYY
C
C	EIGENVALUES AND EIGENVECTORS
C
	TRACE = SXX + SYY		! SUM OF EIGENVALUES
	DET = SXX*SYY - SXY**2		! PRODUCT OF EIGENVALUES
	EVAL1 = .5*(TRACE + SQRT(TRACE**2 - 4.*DET))
	EVAL2 = .5*(TRACE - SQRT(TRACE**2 - 4.*DET))
	IF(EVAL2.GT.EVAL1) THEN
	  EVAL1 = EVAL2
	  EVAL2 = .5*(TRACE + SQRT(TRACE**2 - 4.*DET))
	ENDIF
	RATIO = -1.
	IF(EVAL1.NE.0.) RATIO = SQRT(ABS(EVAL2/EVAL1))
C	IN EIGENVECTORS, TAKE X = 1. UNLESS IT IS ZERO
	IF(SXY.NE.0.) THEN
	  Y1 = (EVAL1 - SXX)/SXY
	  Y2 = (EVAL2 - SXX)/SXY
	  SLOPEV = Y1
	ELSE
	  Y1 = 0.
	  Y2 = 1.
	  X2 = 0.
	  SLOPEV = 1.E8
	ENDIF
C	print*,'ev,slope,slopev',eval1,eval2,slope,slopev
C	print*,'ratio',ratio
	SLOPE = SLOPEV
C
	RETURN	  
	END
	options/extend_source
!------------------------------------------------------------------------------
	REAL*4		function	APMCAL(IANT,NTM)
	implicit	none
!	include		'apc_fit_def.for/nolist'
	real*4 		coeff(5),const(5),csq(5),corrf(5)
	integer*4 	iant,ntm
!
!	iant=1 is X_PK, 2 is Y_PK, 3 is X_DC, 4 is Y_DC, 5 is Z_DC
!
C	the following were used until Nov 1999
C	data coeff /.084848, .09678, .080956, .10424, .06669/
C	data const /13.315,  16.090,  13.069, 16.613, 9.0504/
C	data csq /-8.4573e-6, 2.2302e-5, 2.2793e-6, -9.197e-6, 5.1049e-6/	
!
	data coeff /.087818, .098714, .083789, .10633, .09728/
	data const /13.781,  16.412,  13.526, 16.954, 13.202/
	data csq /-8.7533e-6, 2.2748e-5, 2.3591e-6, -9.381e-6, 7.4466e-6/	
c
	apmcal = coeff(iant)*ntm - const(iant) + csq(iant)*ntm**2

	return
	end
