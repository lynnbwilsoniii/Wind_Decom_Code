	SUBROUTINE MAKEFILE(CH)
C
C	THIS IS MAKEFILE21
C
C	A PROGRAM TO SEARCH FOR UPSTREAM OR SOLAR WIND LANGMUIR WAVES
C		 WITH MULTIPLE SPECTRAL PEAKS  
C		 INTENDED FOR USE IN CALCULATING GENERATION OF EM MODE
C	THE FIRST RUNS GOT TOO CONFUSED BY MULTIPLE PEAKS WHEN THE
C		PEAKS WERE BROAD, AND THERE WAS STATISTICAL ERROR.
C	THAT PROGRAM WAS SAVED AS MAKEFILE21.OLD. 
C	FOR LANGMUIR WAVES DUE TO A 5 KEV BEAM AND VSW = 500 KM/S
C		AND FP = 20 KHZ
C		1 DOPPLER DELTA F = K VSW = 240 HZ = 4 STEPS
C
C	IN NOV 2003 I COPIED THIS TO MAKEFILE21.OLD2 AND STARTED NEW CRITERIA
C		THIS ONE IS GOING TO LOOK AT MOMENTS OF THE MAIN PEAK.  A
C		LARGE SECOND MOMENT OF THE FREQUENCY, WEIGHTED BY POWER, 
C		SHOULD INDICATE MULTIPLE PEAKS
C	PROCEEDURE:  FIND SPECTRAL PEAK (SR FINDMAIN),  CALCULATE MOMENTS
C		OF FREQUENCY (FANDBW?)  
C
	COMMON /XFER/ SPHASE(1025)
	COMMON /FRLIMITS/ FFTMIN,FFTMAX
	COMMON /NOISE_LIM/ XNS
	integer*4 ch,ok,okt,OK1,OK2,SCETI4(2),N1DATA(2048),N2DATA(2048)
	INTEGER*4 W_CHANNEL_CLOSE,W_EVENT,RET_SIZE,W_MESSAGES_OFF
	INTEGER*4 W_ITEM_I4,W_ITEM_R4,W_ITEM_R8
	INTEGER*4 TDS_CHANNEL,ISRC,SUNCLOCK,ERT(2),ERTDAY
	REAL FCOUNT(2),FAVR(2),FSTD(2),F3MOM(2),FBW(2)
	REAL*8 SCET8,XGSE,YGSE,ZGSE,RGSE
	REAL DBSPEC1(1025),V1DATA(2048),PHDIFF(1025)
	REAL DBSPEC2(1025),V2DATA(2048)
	REAL DBSUM(1025)
	REAL EVAL(2),EVEC(2,2),EVLT(2),EVCT(2,2),LEFFX,LEFFY
	REAL F(10),AMP(10),BW(10),SKEW(10),SKEWT(2),XYANG(10),ELLIP(10)
	REAL FT(2),AMPT(2),BWT(2),FM4T(2),RATIO(2)
	REAL FREQ(1025)
	REAL FPK(5),BWPK(5),AMPK(5)
	character*32 ITEM
	character*4 event
	DATA TWOPI /6.2831853/
	DATA YXRATIO /11.8/
C	ABOVE BASED ON LEFFX = 41.1, LEFFY = 3.79
	DATA LEFFX,LEFFY/ 41.1,3.79/
	DATA PXTOT,PYTOT /0.,0./
	DATA RE /6.378E3/
	DATA ANGTOB,TDIST /0.,0./
	DATA NFLLIMP,NFUPLIMP /40,1023/
c	data event /'TDSF'/
	data event /'FILL'/
	DATA LIMSCAN /2/
	DATA NO_LANGW /0/
	DATA BWLIM /75./
	DATA XNS /-90./
C
	CONST1 = (1./LEFFX)**2		! DO IN (VOLTS/M)**2
	CONST2 = (1./LEFFY)**2
	YXSQ = YXRATIO**2
	IFOUND = 0
C
C	STANDARD FORMAT FOR TDSVIS
C
 1114	FORMAT(I10,I7,I10,I3,A2,3F7.0,F7.2,F6.2,F7.0,F6.1,3F7.1,2F7.1
     1		,F6.3)
C
C	CALCULATE FREQUENCIES FOR SPECTRUM
C
	SPS = 120000.
	DO N = 1,1025
	  FREQ(N) = (N-1)*SPS/2048.    ! FREQ(N) GOES WITH DBSPECT(N)
C	  DBSPECT(2) IS LOWEST NON-ZERO FREQUENCY, DBSPECT(1) IS DC
	ENDDO
C
C	OPEN(UNIT=90,FILE='MAKEFILE21.RESULTS',STATUS='OLD',ACCESS='APPEND')
 100	ok = w_event(ch,event)
C
C	CHECK FOR END OF RECORD
C
	if (ok.ne.1) then
		if(ok.eq.82) then
		   ok = w_channel_close(ch)
C		   CLOSE(UNIT=90)
		   return
	        endif
		write(6,*) 'cannot open ',event, ', ok=', ok
	endif
C
C	END OF END OF RECORD CHECK
C
C	OKT = W_MESSAGES_OFF(ch)
C
C
	ITEM = 'FAST_RX_SPEED'
	ok = W_ITEM_I4(ch, item, ISPS, 1, ret_size)
	IF(ISPS.NE.0) GO TO 100
C
	ITEM = 'CHANNEL'
	ok = W_ITEM_I4(ch, item, TDS_CHANNEL, 1, ret_size)
C
	IPROS = 4
	IF(TDS_CHANNEL.EQ.1) THEN
C	  ITEM = 'DATA'
C	  ok1 = W_ITEM_I4(ch, item, N1DATA, 2048, ret_size)
	  CALL TDS_PHYS(CH,IPROS,N1DATA,V1DATA,DBSPEC1)
	  ITEM = 'EVENT_NUMBER'
	  ok = W_ITEM_I4(ch, item, NO_EVT1, 1, ret_size)
	  MAXCH1 = 0
	  DO N = 1,2048
	    MAXCH1 = MAX0(MAXCH1,IABS(N1DATA(N)-128)) 
	  ENDDO
	  DO N = 1,1025
	    PHDIFF(N) = SPHASE(N)
	  ENDDO
	  GO TO 100
	ELSEIF(TDS_CHANNEL.EQ.2) THEN
C	  ITEM = 'DATA'
C	  ok2 = W_ITEM_I4(ch, item, N2DATA, 2048, ret_size)
	  CALL TDS_PHYS(CH,IPROS,N2DATA,V2DATA,DBSPEC2)
	  ITEM = 'EVENT_NUMBER'
	  ok = W_ITEM_I4(ch, item, NO_EVT, 1, ret_size)
	  IF(NO_EVT.NE.NO_EVT1) GO TO 100
	  MAXCH2 = 0
	  DO N = 1,2048
	    MAXCH2 = MAX0(MAXCH2,IABS(N2DATA(N)-128)) 
	  ENDDO
	  DO N = 1,1025
	    PHDIFF(N) = PHDIFF(N) - SPHASE(N)
	  ENDDO
	ELSE
	  GO TO 100
	ENDIF
C
CDIAG	PRINT*,'******START EVENT',NO_EVT1,NO_EVT,' *****'
	PRINT*,'******START EVENT',NO_EVT1,NO_EVT,' *****'
C
	IF(TDS_CHANNEL.EQ.1) GO TO 100		! GO GET CHANNEL 2
	IF(TDS_CHANNEL.NE.2) GO TO 100
C
c*************
C	if(no_evt.ne.12919165) go to 100
C
	DO N = 1,1025
	  TPWR = 10.**(.1*DBSPEC1(N))/LEFFX**2 + 
     1		10.**(.1*DBSPEC2(N))/LEFFY**2
	  DBSUM(N) = 10.*ALOG10(TPWR)
C	write(75,*) freq(n),dbspec1(n),dbspec2(n),dbsum(n)
	ENDDO
C
C	SET STORAGES
C
	DO N = 1,10
	  BW(N) = 0.
	  F(N) = 0.
	  AMP(N) = 0.
	  ELLIP(N) = 0.
	  XYANG(N) = 0.
	ENDDO
C
C	FIND LARGEST PEAK
C
	N1 = 18			! LOWEST FREQ ABOUT 1 KHZ
	N2 = 1024
	INC = 1
	CALL FINDMAIN(N1,N2,INC,DBSUM,NPK,FPK)
	print*,'largest peak,no.,f,db',npk,fpk,dbsum(npk)
C	LIMIT TO FAIRLY LARGE PEAKS
c	IF(DBSUM(NPK).LT.(XNS+20.)) GO TO 100
C
C	DETERMINE ITS BANDWIDTH AND GO BACK IF PEAK IS NOT NARROW
C		I HAD A HARD TIME FINDING A RELIABLE FREQUENCY AND
C		BANDWIDTH ROUTINE.  FANDBW1 FITS THE TWO-POLE
C		CURVE TO THE HIGHEST 3 POINTS.  SOMETIMES IT GIVE
C		A NEGATIVE NUMBER FOR THE SQUARE OF THE BANDWIDTH. 
C		I MAY HAVE FIXED THIS, BUT I AM SUSPICIOUS AND DON'T
C		USE IT.
C	1 FITS FORMULA TO HIGHEST 3 POINTS 
C	2 DOES POWER INTEGRAL
C	3 MAKES ESTIMATES FOR POSSIBLE LEAST SQUARE FIT, NOT DONE YET 
C	4 
C	5 
C
C	  CALL ADJUST(NSVH1,N1SV1,N1SV,NPK2,NPK3)
C	  IF(IER.NE.0) GO TO 160
C	  IF(DBSUM(NPK2).LT.(XNS+10.)) GO TO 150
C
C	  DETERMINE ITS BANDWIDTH, NO, REQUIRE IT TO BE 10. DB ABOVE BCKGD
C	  REQUIRE SIGNIFICANT HEIGHT, IN VOLTS/M, NOISE FOR X IS -75
C	  -20 LOG(41.1) = -107 DB.  FOR Y IS -95 - 20 LOG(3.79) = -107 DB
C	  ALSO
C
	N1SV = MAX0(NPK-25,N1)
	N2SV = MIN0(NPK+25,1023)
	CALL FANDBW2(N1SV,N2SV,FREQ,DBSPEC1,DBSPEC2,NPK,FT,BWT,SKEWT,FM4T)
	print*,'bwt,skewt ',bwt,skewt
	print*,'fm4t ',fm4t
	if(1) goto 100
C
	CALL EEVAL(N1SV,N2SV,V1DATA,V2DATA,EVLT,EVCT,EPT,XYA)
	  IER = 0
	  NO_PKS = 1
	  IF(IER.NE.0) THEN
	    NO_PKS = NO_PKS + 1
	    F(2*NO_PKS-1) = FT(1)
	    F(2*NO_PKS) = FT(2)
	    BW(2*NO_PKS-1) = BWT(1)
	    BW(2*NO_PKS) = BWT(2)
	    AMP(2*NO_PKS-1) = DBSUM(NPK2)
	    AMP(2*NO_PKS) = DBSPEC1(NPK2)
cdiag  	  print*,'2nd ,npk,ellip,xyang',npk2,ept,PHDIFF(NPK2)
	    ELLIP(NO_PKS) = EPT
	    XYANG(NO_PKS) = XYA
	    NSVH1 = N1SV
	  ENDIF
 160	  CONTINUE
C
 150	CONTINUE
C
cdiag	print*,'end up scan,no_pks=',no_pks
cdiag	PRINT*,'LOOK FOR LOWER PEAKS'
C
C
 200	CONTINUE
C
	ITEM = 'WIND_ORBIT_X(GSE)_R8'
	ok = W_ITEM_R8(ch, item, XGSE, 1, ret_size)
	XRE = XGSE/RE
	ITEM = 'WIND_ORBIT_Y(GSE)_R8'
	ok = W_ITEM_R8(ch, item, YGSE, 1, ret_size)
	YRE = YGSE/RE
	ITEM = 'WIND_ORBIT_Z(GSE)_R8'
	ok = W_ITEM_R8(ch, item, ZGSE, 1, ret_size)
	ZRE = ZGSE/RE
	RRE = SQRT(XRE**2+YRE**2+ZRE**2)
C
C	IF(RGSE.LT.6.4D05) THEN			! LIMIT 100 RE
C	    ADVANCE BY ONE HOUR AND GET ANOTHER EVENT
C	    ITEM = 'EVENT_SCET_R8'
C	    OK = W_ITEM_R8(ch, item, SCET8, 1, ret_size)
	    ITEM = 'EVENT_SCET'
	    ok = W_ITEM_I4(ch, item, SCETI4, 2, ret_size)
C	    PRINT*,RGSE/6.38E3,'INSIDE 100 RE',SCETI4
C	    SCET8 = SCET8 + 1.D00/24.D00
C	    CALL W_CHANNEL_POSITION(CH,SCET8)
C	    GO TO 100
C	  ENDIF
C
C
	ITEM = 'EVENT_TM_SCET_I4'
	ok = W_ITEM_I4(ch, item, ERT, 2, ret_size)
	ERTDAY = MOD(ERT(1),100)
	ITEM = 'SOURCE'
	ok = W_ITEM_I4(ch, item, ISRC, 1, ret_size)
	ITEM = 'EVENT_NUMBER'
	ok = W_ITEM_I4(ch, item, NO_EVT, 1, ret_size)
	ITEM = 'EVENT_SCET'
	ok = W_ITEM_I4(ch, item, SCETI4, 2, ret_size)
	ITEM = 'WIND_MFI_BX(GSE)_R4'
	ok = W_ITEM_R4(ch, item, BX, 1, ret_size)
	ITEM = 'WIND_MFI_BY(GSE)_R4'
	ok = W_ITEM_R4(ch, item, BY, 1, ret_size)
	ITEM = 'WIND_MFI_BZ(GSE)_R4'
	ok = W_ITEM_R4(ch, item, BZ, 1, ret_size)
	ITEM = 'SUN_ANGLE'
	ok = W_ITEM_I4(ch, item, SUNCLOCK, 1, ret_size)
C	ITEM = 'WIND_3DP_E_TEMP_R4'
C	ok = W_ITEM_R4(ch, item, TEMPE, 1, ret_size)
C	ITEM = 'WIND_3DP_ION_TEMP_R4'
C	ok = W_ITEM_R4(ch, item, TEMPI, 1, ret_size)
	item = 'WIND_3DP_EF_250EV_R4'
	ok = w_item_r4(CH, item, EF250, 1, ret_size)
	item = 'WIND_3DP_EF_1KEV_R4'
	ok = w_item_r4(CH, item, EF1, 1, ret_size)
	item = 'WIND_3DP_EF_5KEV_R4'
	ok = w_item_r4(CH, item, EF5, 1, ret_size)
	item = 'WIND_3DP_EF_20KEV_R4'
	ok = w_item_r4(CH, item, EF20, 1, ret_size)
	ITEM = 'WIND_3DP_ION_DENSITY_R4'
	ok = W_ITEM_R4(ch, item, DENS, 1, ret_size)
C	ITEM = 'WIND_3DP_ION_VX(GSE)_R4'
C	ok = W_ITEM_R4(ch, item, VX, 1, ret_size)
C	ITEM = 'WIND_3DP_ION_VY(GSE)_R4'
C	ok = W_ITEM_R4(ch, item, VY, 1, ret_size)
C	ITEM = 'WIND_MFI_BMAG_R4'
C	ok = W_ITEM_R4(ch, item, BMAG, 1, ret_size)
	ITEM = 'WIND_SPIN_RATE_R4'
	ok = W_ITEM_R4(ch, item, SPINRATE, 1, ret_size)
	if(ok.ne.1) then
	  spinrate = 2.
	endif
C
C	ITEM = 'CAL_PA'
C	ok = W_ITEM_I4(ch, item, ICAL, 1, ret_size)
C	IF(ICAL.NE.0) GO TO 100
C	HAVE TO EXCLUDE CALS BY TIMING.  
c		to exclude cals
	  if(sceti4(2).ge.010000.and.sceti4(2).lt.011000) THEN
		PRINT*,'CALIBRATE, NO_EVT=',SCETI4,NO_EVT
		GO TO 100
	  endif
C
C	CALL DIFFFK(XRE,YRE,ZRE,BX,BY,BZ,DDIFF,XT,YT,ZT,XI,YI,ZI,IN)
C
	TDIST = (XRE-XT)**2 + (YRE-YT)**2 + (ZRE-ZT)**2
	TDIST = SQRT(TDIST)
C
C	CRITERIA
C
cdiag	print*,'start criteria, diff=',ddiff
c	IF(DDIFF.GT.0.) GO TO 100
C
	XMAX = 0.
	YMAX = 0.
	XMIN = 0.
	YMIN = 0.
	DO N = 1,2048
	  XMAX = AMAX1(XMAX,V1DATA(N))
	  YMAX = AMAX1(YMAX,V2DATA(N))
	  XMIN = AMIN1(XMIN,V1DATA(N))
	  YMIN = AMIN1(YMIN,V2DATA(N))
	ENDDO
C	print*,'xmin,max,y',xmin,xmax,ymin,ymax
	XMAX = AMAX1(XMAX,-XMIN)
	YMAX = AMAX1(YMAX,-YMIN)

C	CHANGE TO mV/m
C	 BASED ON LEFFX = 41.1, LEFFY = 3.79
	XMAX = 1000.*XMAX/LEFFX
	YMAX = 1000.*YMAX/LEFFY	
	  IFOUND = 0
C	  GO TO 100
C
	FP = 9.E3*SQRT(DENS)			  ! PLASMA FREQ IN KHZ
C	IF(FREQMAX.LT..75*FP.OR.FREQMAX.GT.1.25*FP) THEN
C	  IF(FP.NE.0.) THEN
C    	   PRINT*,'FREQ NOT CLOSE TO PLASMA FREQ, FP,RATIO-',FP,FREQMAX/FP
C	  ELSE
C     	   PRINT*,'FREQ NOT CLOSE TO PLASMA FREQ, FP,F ',FP,FREQMAX
C	  ENDIF
C	  GO TO 100
C	ENDIF
C
C	FCE = .028*BMAG
C	BETA = .402*(TEMPE+TEMPI)/BMAG**2
C
c	IF(FAVR(1).GT..8*FP) THEN
C	  PRINT*,'EVENT NO.',NO_EVT,' FREQ', F(1),' MAX',
C     1		MAXCH1,MAXCH2
c	  IFOUND = 0
c	ENDIF
C
C*****	CHECKING
c	PRINT*,'VMATRIX',VMATRIX(1,1),VMATRIX(1,2),VMATRIX(2,2)
c	PRINT*,'EVALS,AXS,PX,PY',EVAL(1),EVAL(2),AXMAJOR,AXMINOR,
c     1		PX,PY
C*****
C
C	PLASMA PARAMETERS, ETC.
C
C	   write(s,'(i8.8,i6.6)',iostat=ios) s_scet(1), s_scet(2)
C	   s_scet = s(1:4)//'/'//s(5:6)//'/'//s(7:8)//' '//
C	1	s(9:10)//':'//s(11:12)//':'//s(13:14)
C
c	print date, time, event no., freq, Px, Py, Vy/Vx, angles of
c		antenna,B, phiB, mag B or fce, fp
C
	  PX = 10.**(.1*DBSPEC1(NPK))/LEFFX**2
	  PY = 10.**(.1*DBSPEC2(NPK))/LEFFY**2
	  RATIO(1) = FM4T(1)/BWT(1)
	  RATIO(2) = FM4T(2)/BWT(2)
	  BWAVR = (PX*BW(1) + PY*BW(2))/(PX+PY)
	  WRITE(80,1015) sceti4,NO_EVT,ERTDAY,EVENT(1:1),FREQ(NPK-1),
     1	    FT,BWT,FM4T,RATIO,EF250,EF1,EF5
	  print*,'skew',skewt,ratio
	  NO_LANGW = NO_LANGW + 1
 1015	format(I10,I7,I10,I3,A2,F7.0,6F7.0,2F6.2,3E12.3)
	  GO TO 100
C
cdiag	print*,'write 90, no_pks=',no_pks
C	WRITE(90,1011) sceti4,NO_EVT,EVENT(1:1),NO_PKS,DDIFF,
C     1	 (F(M),M=1,10,2)
C     1	 (F(M),M=1,2*NO_PKS,2)
C	WRITE(91,1012) sceti4,NO_EVT,EVENT(1:1),NO_PKS,SKEWT,
C     1	 (BW(M),M=1,10)
C     1	 (BW(M),M=1,10,2)
C	WRITE(92,1013) sceti4,NO_EVT,EVENT(1:1),NO_PKS,XRE,YRE,ZRE,
C     1	 (AMP(M),M=1,10,2)
C	WRITE(93,1014) sceti4,NO_EVT,EVENT(1:1),NO_PKS,
C     1	 (ELLIP(M),M=1,5),(XYANG(M),M=1,5)
C	WRITE(93,1012) sceti4,NO_EVT,EVENT(1:1),NO_PKS,
C     1	 (SKEW(M),M=1,2*NO_PKS,2)
C
 1011	format(I10,I7,I10,A2,I3,F8.1,5F8.1)
 1012	format(I10,I7,I10,A2,I3,2E12.3,10F6.0)
 1013	format(I10,I7,I10,A2,I3,3F7.0,5F7.1)
 1014	format(I10,I7,I10,A2,I3,5F6.3,5F6.0)
C
C
	IF(OK.NE.82) GO TO 100
	CLOSE(UNIT=90)
	PRINT*,'NO OF LANGMUIR WAVES =',NO_LANGW
	return
	end
	SUBROUTINE FANDBW1(ICHANN,DB,NPEAK,F,BW,AMP,NERROR)
C
	DATA SPS /120000./
	REAL F(2),AMP(2),BW(2),DB(1025)
C
	FREQMAX = (NPEAK-1)*SPS/2048.
C
C	FIT SPECTRUM(F) = A DF^2/((F-F0)^2 + DF^2) TO HIGHEST 3 POINTS
C		this routine did not work well, as it had a tendency
C		to give negative (bandwidth)^2
C
	SINV1 = 10.**(-.1*DB(NPEAK-1))
	SINV2 = 10.**(-.1*DB(NPEAK))
	SINV3 = 10.**(-.1*DB(NPEAK+1))
C	print*,'ch,db',ichann,db(npeak-1),db(npeak),db(npeak+1)
C	print*,'sinv',sinv1,sinv2,sinv3
	DELF = 	SPS/2048.
	TEMP1 = SINV1 - 2.*SINV2 + SINV3
	ADF2 = 2.*DELF**2/TEMP1
C	print*,'temp1,adf2',temp1,adf2
	TEMP2 = ADF2*(SINV3 - SINV1) - 4.*FREQMAX*DELF
	F0 = -.25*TEMP2/DELF
	AINV = SINV2 - (FREQMAX-F0)**2/ADF2
	AMP(ICHANN) = 1./AINV
C	print*,'chk ',freqmax-f0,sinv2,(freqmax-f0)**2/adf2,ainv
	BW2 = ADF2*AINV
cdiag	PRINT*,'FANDBW1,A,F0,TEMP2,BW2',AMP(ICHANN),F0,TEMP2,BW2
	IF(BW2.LT.0.) THEN
	  NERROR = 1
	  F0 = FREQMAX + .5*SINV2*(1./SINV3 - 1./SINV1)*DELF
C	  TEMP IS THE FRACTIONAL DECREASE OF SIGNAL AT THE SIDE POINTS
C	  IT WOULD BE .5 IF THE SIDE POINTS WERE 3 DB DOWN, AND WOULD BE
C	  1. FOR AN INFINITLY SHARP PEAK 
	  TEMP = 1. - SINV2*(.5/SINV1 + .5/SINV3)
	  BW2 = DELF**2/((SINV1+SINV3)/SINV2 - 1.)
C	  BW(ICHANN) = 2.*DELF*(1.-TEMP)
	  BW(ICHANN) = SQRT(BW2)
	  AMP(ICHANN) = 1./SINV2
	ELSE
	  NERROR = 0
	  BW(ICHANN) = SQRT(BW2)
	ENDIF
C	PRINT*,'FANDBW1,A,F0,BW',AMP(ICHANN),F0,BW(ICHANN)
C
	RETURN
	END
	SUBROUTINE FANDBW2(N1,N2,FREQ,DBX,DBY,NPEAK,FAVR,FBW,SKEW,F4M)
C
C	DUE TO ROUNDOFF ERROR, IT WAS NECESSARY TO COMPUTE MOMENTS RELATIVE
C		TO FPEAK
C
	DATA SPS /120000./
	REAL AMP(2),DBX(1025),DBY(1025),FREQ(1025)
	REAL FCOUNT(2),FAVR(2),FSTD(2),F3MOM(2),FBW(2),SKEW(2),F4M(2)
	DATA NFLLIMP,NFUPLIMP /4, 1024/
C
	CONST1 = (1./41.1)**2		! DO IN (VOLTS/M)**2
	CONST2 = (1./3.79)**2
C
	IF(N1.GT.N2) THEN
	   N2T = N1
	   N1T = N2
	ELSE
	   N1T = N1
	   N2T = N2
	ENDIF
C
	NPEAK = N1T
	VMAX = 0.
	DO NC = 1,2
	  FCOUNT(NC) = 1.E-20
	  FAVR(NC) = 0.
	  FSTD(NC) = 0.
	  F3MOM(NC) = 0.
	  F4M(NC) = 0.
C
C	DO AVERAGE FREQ AND BW TO ADJUST LIMITS
C
	  DO N = N1T,N2T
	    IF(NC.EQ.1) THEN
		VLT = CONST1*10.**(.1*DBX(N))
	    ELSE
		VLT = CONST2*10.**(.1*DBY(N))
	    ENDIF
	    IF(VLT.GT.VMAX) THEN
	       NPEAK = N
	       VMAX = VLT
	    ENDIF
	    RFREQ = FREQ(N)
	    FCOUNT(NC) = FCOUNT(NC) + VLT
	    FAVR(NC) =  FAVR(NC)  + VLT*RFREQ
	  ENDDO
	  F0 = FAVR(NC)/FCOUNT(NC)
	  FAVR(NC) = F0
C
	  DO N = N1T,N2T
	    IF(NC.EQ.1) THEN
		VLT = CONST1*10.**(.1*DBX(N))
	    ELSE
		VLT = CONST2*10.**(.1*DBY(N))
	    ENDIF
	    RFREQ = FREQ(N) - F0
	    FSTD(NC) =  FSTD(NC)  + VLT*RFREQ**2
	    F3MOM(NC) = F3MOM(NC) + VLT*RFREQ**3
	    F4M(NC)  =  F4M(NC)   + VLT*RFREQ**4
	  ENDDO
	  FN = FCOUNT(NC)
	print*,'before',nc,fcount(nc),favr(nc),fstd(nc),f3mom(nc),f4M(nc)
	  FBW(NC) = SQRT(FSTD(NC)/FN)
	  SKEW(NC) = F3MOM(NC)/FN
	  F4M(NC) = SQRT(F4M(NC)/FN)
	  F4M(NC) = SQRT(F4M(NC))
	ENDDO
C
	RETURN
	END
	SUBROUTINE FANDBW3(ICHANN,DBX,DBY,NPEAK,F,BW,AMP)
C
	DATA SPS /120000./
	DATA NSVL,NSVH,NSPMAX1 /4,4,4/
	REAL X(10),F(10),AMP(10),BW(10)
C
C	ESTIMATES FOR FITTING SPECTRUM(F) = A DF^2/((F-F0)^2 + DF^2)
C
	A = 10.**(.1*DBX(NPEAK))
	X(1) = 1./A
	F0 = (NPEAK-1)*SPS/2048.
	X(3) = F0
	DELF = (NSVH-1)*SPS/2048. - F0
	SFAR = 	10.**(.1*DBX(NSVH))
	print*,'A',A
	print*,'f0,delf,sfar',f0,delf,sfar
	ADF21 = 10.**(.1*DBX(NSVH))*DELF**2/(1. - SFAR/A)
	DELF = (NSVL-1)*SPS/2048. - F0
	SFAR = 	10.**(.1*DBX(NSVL))
	print*,'f0,delf,sfar',f0,delf,sfar
	ADF22 = 10.**(.1*DBX(NSVL))*DELF**2/(1. - SFAR/A)
	ADF2 = .5*(ADF21+ADF22)
	X(2) = 1./ADF2
	print*,'nspmax1,nsvl,nsvh',nspmax1,nsvl,nsvh
	print*,'adf21,adf22,adf2',adf21,adf22,adf2
	AMP(1) = 1./X(1)
	F(1) = X(3)
	BW(1) = X(1)/X(2)	
	RETURN
	END
	SUBROUTINE FINDPEAK(N1,N2,INC,N1S,DBSP,NPK,FPK,IER)
C
	REAL DBSP(1025)
	REAL X(25)
	DATA LIMSCAN /2/
	DATA SPS /120000./
	COMMON /NOISE_LIM/ XNS
C
C	FINDS NEXT PEAK BETWEEN N1 AND N2 BY SCANNING UNTIL TWO
C		SUCCESIVE SAMPLES INCREASE, I.E. WHEN VALLEY BETWEEN PEAKS
C		IS CROSSED.  BUT DO NOT STOP IF SAMPLE IS GREATER THAN
C		ANY PREVIOUS SAMPLE
C	ON RETURN, THERE ARE VARIOUS OUTCOMES.  (1) A PEAK IS FOUND
C		BETWEEN N1 AND N1S.  (1A) EXIT AFTER FINDING THIS PEAK
C		WHEN SIGNAL GOES DOWN CLOSE TO BACKGROUND (1B) EXIT AFTER
C		TWO SUCCESSIVE SAMPLES INCREASE.  
C		(2) NO PEAK IS FOUND, AS MAXIMUM VALUE FOUND IS BELOW A
C		LIMIT.  
C		IN ANY OF THESE CASES, THE REGION WHICH HAS BEEN SEARCHED
C		IS N1 TO N1S.  IT MAY BE NECESSARY TO SEARCH N1S TO N2 IF
C		N2 IS BEYOND (LESS THAN OR GREATER THAN, DEPENDING ON INC) 
C		N1S BUT THIS IS UNDER THE CONTROL OF THE CALLING PROGRAM.
C
c	do n = n1,n2
C	do n = 250,n2
C	  print*,n,dbsp(n)
C	enddo
C
	SMAX = DBSP(N1)
	SMIN = DBSP(N1)
	SSAVE = DBSP(N1)
	SLIM = AMAX1(XNS+10.,SSAVE-70.) 
	NPK = N1
	NSVL = N1
	LCOUNT = 0
cdiag	print*,'START fpk,n1,n2,slim',n1,n2,slim
C
 20	CONTINUE
C
	SMAX = DBSP(N1)
cdiag	print*,'n,dbsp,lcount',n1,dbsp(n1),lcount
	DO N = N1+INC,N2,INC
	    NSVH = N - LIMSCAN*INC
	    SMIN = AMIN1(SMIN,DBSP(N))
C	print*,'n,lcount,smax,ssave',n,lcount,smax,ssave
	    IF(DBSP(N).GT.SMAX) THEN
		NPK = N
		SMAX = DBSP(N)
		SLIM = AMAX1(SLIM,SMAX-50.) 
		LCOUNT = 0		! START OVER FOR A NEW PEAK
	    ENDIF
C
cdiag	print*,'n,dbsp,lcount',n,dbsp(n),lcount
	    IF(DBSP(N).GT.SSAVE) THEN
	      LCOUNT = LCOUNT+1
	      IF(LCOUNT.GE.LIMSCAN) THEN
		GO TO 21
	      ENDIF
	    ELSE
	      LCOUNT = 0
	    ENDIF
	    N1S = NSVH
	    NCOUNT = IABS(N-N1)+1
C	    REQUIRE FIVE POINTS TO A PEAK 
	    IF(DBSP(N).LT.SLIM.AND.NCOUNT.GE.5) THEN
	 	N1S = N
		GO TO 21
	    ENDIF
	    SSAVE = DBSP(N)
	ENDDO
C
 21	IER = 0
C		REQUIRE FIVE POINTS TO A PEAK AND SMAX GT SLIM AND
C		PEAK 10 DB OR MORE ABOVE MINIMUM
cdiag	print*,'fpk',smax,lcount,nsvl,nsvh,npk
	IF(SMAX.LT.SLIM.OR.SMAX.LT.(SMIN+10.)) THEN
cdiag	print*,'return with ier = 1,smax,slim,smin',smax,slim,smin
	  IER = 1
	  RETURN
	ENDIF
	FPK = (NPK-1)*SPS/2048.
cdiag	print*,'findpeak return with n1s,ier =',n1S,ier
C
	RETURN
	END
	SUBROUTINE FINDPEAKgiveup(N1,N2,INC,N1S,N2S,DBSP,NPK,FPK,IER)
C
	REAL DBSP(1025)
	REAL X(25)
	DATA LIMSCAN /2/
	DATA SPS /120000./
	COMMON /NOISE_LIM/ XNS
C
C	FINDS NEXT PEAK BETWEEN N1 AND N2 BY SCANNING UNTIL TWO
C		SUCCESIVE SAMPLES DECREASE
C
c	do n = n1,n2
c	  print*,n,dbsp(n)
c	enddo
	SMAX = DBSP(N1)
	SSAVE = DBSP(N1)
	SLIM = AMAX1(XNS,SSAVE-80.) 
	NPK = N1
	NSVL = N1
	LCOUNT = 0
	print*,'START fpk,n1,n2,slim',n1,n2,slim
C
 20	CONTINUE
C
	DO N = N1+INC,N2,INC

	    NSVH = N - LIMSCAN
	print*,'n,lcount,smax,ssave',n,lcount,smax,ssave
	    IF(DBSP(N).GT.SMAX) THEN
		NPK = N
		SMAX = DBSP(N)
		LCOUNT = 0		! START OVER FOR A NEW PEAK
	    ENDIF
C
	    IF(DBSP(N).LT.SSAVE) THEN
	      LCOUNT = LCOUNT+1
	print*,'n,dbsp,lcount',n,dbsp(n),lcount
	      IF(LCOUNT.GE.LIMSCAN) THEN
		GO TO 21
	      ELSE
		LCOUNT = 0
	      ENDIF
	    ENDIF
	    IF(DBSP(N).LT.SLIM) GO TO 21
	    SSAVE = DBSP(N)
	ENDDO
C
 21	IER = 0
C		REQUIRE FIVE POINTS TO A PEAK
	print*,'fpk',smax,lcount,nsvl,nsvh,npk
	N1S = NSVH
	N2S = N2
	IF((NSVH-NSVL).LT.4.OR.SMAX.LT.SLIM) THEN
C	    RESTART FOR NEW PEAK
	    IF(NSVH.LT.N2) THEN
		IER = 1
		N1 = NSVH + LIMSCAN
	    ELSE
		IER = 1
		RETURN
	    ENDIF
	ENDIF
	FPK = (NPK-1)*SPS/2048.
	N1 = NSVH
C
	RETURN
	END
	SUBROUTINE FINDPEAKOLD(N1,N2,INC,DBSP,NPK,FPK)
C
	REAL DBSP(1025)
	REAL X(25)
	DATA SPS /120000./
	DATA STEST /15./
C
C	FINDS FREQUENCY OF HIGHEST PEAK BETWEEN N1 AND N2
C
C	  FIND MAXIMUM IN SPECTRUM
C
	SMAX = DBSP(N1)
	SMIN = DBSP(N1)
	NPK = N1
	DO N = N1+INC,N2,INC
	  SMIN = AMIN1(SMIN,DBSP(N))
C	 CHECK THAT DBSP(N) IS A PEAK
	  IF(DBSP(N-1).LT.DBSP(N).AND.DBSP(N+1).LT.DBSP(N))THEN
C	 IS IT THE LARGEST PEAK?
	    IF(DBSP(N).GT.SMAX.AND.DBSP(N).GT.(SMIN+STEST)) THEN
	        SMAX = DBSP(N)
	        NPK = N
		SMIN = SMAX
	       PRINT*,'in findpeak MAX:N,F,SMAX',NPK,(NPK-1)*SPS/2048.,SMAX
	    ENDIF
	  ENDIF
	ENDDO
	FPK = (NPK-1)*SPS/2048.
C
	RETURN
	END
	SUBROUTINE FINDMAIN(N1,N2,INC,DBSUM,NPK,FPK)
C
C	REAL DBX(1025),DBY(1025),DBSUM(1025)
	REAL DBSUM(1025)
	REAL X(25)
	DATA SPS /120000./
	COMMON /NOISE_LIM/ XNS
C
C	FINDS FREQUENCY OF HIGHEST PEAK BETWEEN N1 AND N2
C
C	  FIND MAXIMUM IN SPECTRUM
C
	SMAX = DBSUM(N1)
	SSAVE = DBSUM(N1)
	NPK = N1
	SLIM = AMAX1(XNS,SSAVE-80.) 
	DO N = N1+INC,N2,INC
	    IF(DBSUM(N).GT.SMAX) THEN
	        SMAX = DBSUM(N)
	        NPK = N
	    ENDIF
	ENDDO
cdiag	PRINT*,'in findmain MAX:N,F,SMAX',NPK,(NPK-1)*SPS/2048.,SMAX
	FPK = (NPK-1)*SPS/2048.
C
	RETURN
	END
	SUBROUTINE EEVAL(N1,N2,V1IN,V2IN,EVAL,EVEC,ELLIP,XYANG)
C
C
	REAL EVAL(2),EVEC(2,2),LEFFX,LEFFY,V1IN(1),V2IN(1)
	REAL V1DATA(2048),V2DATA(2048)
	DATA LEFFX,LEFFY/ 41.1,3.79/
C
C	ALGEBRA IN WIND N.B. VOL 4 P 101
C
	IF(N1.GT.N2) THEN
	   N2T = N1
	   N1T = N2
	ELSE
	   N1T = N1
	   N2T = N2
	ENDIF
C
	SXX = 0.
	SYY = 0.
	SXY = 0.
	SXY2 = 0.
C
C	REMOVE AVERAGES
C
	V1AVR = 0.
	V2AV2 = 0.
	COUNT = 1.E-10
	DO N = N1T,N2T
	  V1AVR = V1AVR + V1IN(N)	
	  V2AVR = V2AVR + V2IN(N)	
	  COUNT = COUNT + 1.
	ENDDO
	V1AVR = V1AVR/COUNT
	V2AVR = V2AVR/COUNT
C
	DO N = N1T,N2T
	  V1DATA(N) = (V1IN(N) - V1AVR)/LEFFX 
	  V2DATA(N) = (V2IN(N) - V2AVR)/LEFFY 
	  SXX = SXX + V1DATA(N)**2
	  SYY = SYY + V2DATA(N)**2
	  SXY = SXY + V1DATA(N)*V2DATA(N)
	ENDDO
	IF(SXX.EQ.0..OR.SYY.EQ.0.) RETURN	! MISSING DATA
	BB = (SXX + SYY)
	DISC = BB**2 - 4.*(SXX*SYY - SXY**2)
	EVAL(1) = .5*(BB + SQRT(DISC))
	EVAL(2) = .5*(BB - SQRT(DISC))
C	FIRST INDEX IS 1 FOR EVAL(1), 2 FOR EVAL(2)
	EVEC(1,1) = 1.
	EVEC(1,2) = -(SXX-EVAL(1))/SXY
	VNORM = EVEC(1,1)**2 + EVEC(1,2)**2
	SNORM = SQRT(VNORM)
	EVEC(1,1) = EVEC(1,1)/SNORM
	EVEC(1,2) = EVEC(1,2)/SNORM
C
	EVEC(2,1) = 1.
	EVEC(2,2) = -(SXX-EVAL(2))/SXY
	VNORM = EVEC(2,1)**2 + EVEC(2,2)**2
	SNORM = SQRT(VNORM)
	EVEC(2,1) = EVEC(2,1)/SNORM
	EVEC(2,2) = EVEC(2,2)/SNORM
C
	ELLIP = SQRT(EVAL(2)/EVAL(1))
cdiag	print*,'eeval',N1,N2,eval,ellip
C
C	ANGLE BETWEEN E AND X ANTENNA
C
	XYANG = ATAN2D(EVEC(1,2),EVEC(1,1))
	IF(XYANG.GT.90.) XYANG = XYANG - 180.
	IF(XYANG.LE.-90.) XYANG = XYANG + 180.
	RETURN
	END
	SUBROUTINE ADJUST(N1,N2SV1,N2SV2,NPK2,NPK3,IER)
C
C	ADJUSTS LIMITS ON X AND Y SO THEY COVER THE SAME PEAK
C
	IF(N1.GT.N2SV1) THEN
	   N2T1 = N1
	   N1T = N2SV1
	   N1T = N2SV2
	ELSE
	   N1T = N1
	   N2T1 = N2SV1
	   N2T = N2SV2
	ENDIF
C
	RETURN
	END
