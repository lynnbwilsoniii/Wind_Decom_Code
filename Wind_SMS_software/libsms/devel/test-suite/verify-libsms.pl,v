head	1.2;
access;
symbols;
locks; strict;
comment	@# @;


1.2
date	2000.05.01.21.22.37;	author jraines;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.27.20.30.09;	author jraines;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fixed printing of libsms version to output file.  (Broken by libsms
1.1.2)
@
text
@#! /usr/bin/perl -I/home/jraines/wind/libsms
# verify-libsms.pl -- run libsms through its paces and compare output with 
#                     known good.  Used for verifying that something wasn't
#                     broken after a code change.  Compares with .kg file.
# Jim Raines, 6Mar00
#
# To Do:
#   - add MASS functions
#
# Modification History
#   Made auto moving of kg files work.  J. Raines, 27Mar00
#
use libsms;
use Getopt::Long;

##############
# perl setup #
##############

# init. some flags
$fOnce = 0; # keeps smsDecommHDB from being run for each cycle

# define some stuff
$thisprog = "verify-libsms";
$version = "1.0";

# get command line options
GetOptions("help!","debug:i","trace:i","kg");

# print usage statement and exit
if ($opt_help){
  print <<EOF;
$thisprog: prints various items from  WIND/SMS to verify that libsms is working.
version: $version 
usage: $thisprog yyyydoy [optional args]
  Processes WIND/SMS data file for yyyydoy.

  optional args:
  --debug=i    set libsms debug level to i
  --trace=i    set libsms trace to i (0 ==> off; 1 ==> on)
  --kg         create known good (kg) file, use -I opt. for different library:
               % perl -I/home/winddata/sw/libsms verify-libsms.pl -kg 19990618

  --help       prints this message
EOF
  exit(0);
}

# set debug and trace levels from options if present or to zero otherwise
if (!$opt_debug) {
  $opt_debug = 0;
}
if (!$opt_trace){
  $opt_trace = 0;
}

# set date based from 1st argument (or use default)
if (@@ARGV >= 1) {
  $Date = $ARGV[0];
}
else {
  print "$thisprog: year and date required; use --help option for syntax\n";
  exit(1);
}


######################
# begin libsms stuff #
######################

# open file
$File = "/home/winddata/LV1/wi_lz_sms_".$Date."_v01.dat";

# print "$File\n";
$result = libsms::smsOpenFile($File);

# init. output file  (note: must do after opening file b/c of smsgver)
$outfile = "$Date.$thisprog";
open(OUT,">".$outfile) or die "Cannot open $outfile.";
print OUT "# data items from WIND/SMS, data date is $Date\n";
print OUT "# generated by $thisprog.pl on ";
print OUT scalar localtime;
printf OUT (", libsms v. %s\n", libsms::smsgver()); 
print OUT "# The columns are in the following order:\n";
print OUT "#   msn spin hh:mm:ss xnpha tnpha mnpha xdvs tdvs tfsr[1] tfsr[2] TOF SSD Sec EGY Rng Stp\n";


## set debug level and trace
$result = libsms::smssetdbg($opt_debug);
print "$thisprog: setting smssetdbg=$result\n";
$result = libsms::smssettrace($opt_trace);
print "$thisprog: setting smssettrace=$result\n";

# must override quality (for now) to compare with before bad EDB dropping
libsms::smssqualover(1);

## read cycle
$ncycle = 0;
while (($result = libsms::smsReadCycle()) == 0) {
  $ncycle++;

  # get time string for cycle
  printf("%s: Cycle[%3.3d] time is %s\n",$thisprog,$ncycle,
	 libsms::smsgtimes()); 

  # write info commuted over many HDBs into memory for later retrieval
  if (!$fOnce) {
    #libsms::smsDecommHDB();
    $fOnce = 1;
  }
  
  for ($nedb=0; $nedb < 60; $nedb++) {
    # EDB header info
    #	printf("%s: EDB[%2.2d] time is %s",$thisprog,$nedb,
    #   smsgtimes()); # get time string for cycle
    
    
    printf OUT
      ("    %3.3d  %3.3d %s    %2.2d    %2.2d    %2.2d   %2.2d   %2.2d     %3.3d     %3.3d",
       $nedb,
       libsms::smsgrevcount($nedb),
       libsms::smsghms(),
       libsms::smsgxnpha($nedb),
       libsms::smsgtnpha($nedb),
       libsms::smsgmnpha($nedb),
       libsms::smsgxdvs($nedb),
       libsms::smsgtdvs($nedb),
       libsms::smsgtfsr($nedb,1),
       libsms::smsgtfsr($nedb,2)
      );

    for ($npha = 0; $npha < libsms::smsgtnpha($nedb); $npha++){
      printf OUT
	(" %3.3d %3.3d %3.3d %3.3d %3.3d %3.3d",libsms::smsgttofd($nedb,$npha),
	 libsms::smsgtssdid($nedb,$npha),libsms::smsgtsector($nedb,$npha),
	 libsms::smsgted($nedb, $npha), libsms::smsgtrange($nedb,$npha),
	 libsms::smsgtstopid($nedb,$npha));
    }

    print OUT "\n";

  }			# loop of EDBs
}			# loop over cycles
close OUT;

## compare with or create known good file

$kgfile = $Date.'.'.$thisprog.'.kg';
if (!$opt_kg){
  ## compare with known good (kg) file
  @@cmd = ('diff', $kgfile, $outfile);
  print "$thisprog: running @@cmd...\n";
  system(@@cmd);
}
else{
  ## copy to known good (.kg) file

  if ( -e $kgfile ){
    @@cmd = ('/bin/mv','--force', $kgfile, $kgfile.'.old');
    print "$thisprog: running @@cmd...\n";
    system(@@cmd) == 0 or print "$thisprog: system with @@cmd failed\n";
  }

  @@cmd = ('/bin/mv', '--force', $outfile, $kgfile);
  print "$thisprog: running @@cmd...\n";
  system(@@cmd) == 0 or print "$thisprog: system with @@cmd failed\n";
}
@


1.1
log
@Initial revision
@
text
@a65 10
# init. output file
$outfile = "$Date.$thisprog";
open(OUT,">".$outfile) or die "Cannot open $outfile.";
print OUT "# data items from WIND/SMS, data date is $Date\n";
print OUT "# generated by $thisprog.pl on ";
print OUT scalar localtime;
printf OUT (", libsms v. %s\n", libsms::smsgver()); 
print OUT "# The columns are in the following order:\n";
print OUT "#   msn spin hh:mm:ss xnpha tnpha mnpha xdvs tdvs tfsr[1] tfsr[2] TOF SSD Sec EGY Rng Stp\n";

d76 11
@
