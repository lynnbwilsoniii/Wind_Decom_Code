<HTML>
<HEAD>
<TITLE>
Description of Perl 5 interface to libsms</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>Description of Perl 5 interface to libsms</H1>
[ Module  : libsms, Package : libsms ]<BR>
   This perl 5 interface to libsms was generated by SWIG.   

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. General Information</A>
<UL><LI> <A HREF="#s1_1_">1.1. Introduction</A>
<LI> <A HREF="#s1_2_">1.2. Function Names</A>
<LI> <A HREF="#s1_3_">1.3. SMS Return Codes</A>
<LI> <A HREF="#s1_4_">1.4. Messages</A>
</UL><LI> <A HREF="#s2_">2. Typical Perl Usage</A>
<LI> <A HREF="#s3_">3. Global functions</A>
<LI> <A HREF="#s4_">4. Specific instrument functions</A>
<UL><LI> <A HREF="#s4_1_">4.1. SWICS</A>
<UL><LI> <A HREF="#s4_1_1_">4.1.1. engineering rates</A>
<LI> <A HREF="#s4_1_2_">4.1.2. PHA words</A>
</UL><LI> <A HREF="#s4_2_">4.2. STICS</A>
<UL><LI> <A HREF="#s4_2_1_">4.2.1. decommuted HDB items</A>
<LI> <A HREF="#s4_2_2_">4.2.2. non-engineering rates</A>
<LI> <A HREF="#s4_2_3_">4.2.3. engineering rates</A>
<LI> <A HREF="#s4_2_4_">4.2.4. STICS PHA</A>
</UL><LI> <A HREF="#s4_3_">4.3. MASS</A>
<UL><LI> <A HREF="#s4_3_1_">4.3.1. engineering rates</A>
<LI> <A HREF="#s4_3_2_">4.3.2. PHA words</A>
</UL>
</UL>
</UL>

<A name="s1_">
<HR><H2>1. General Information</H2></A>
<A name="s1_1_">
<H3>1.1. Introduction</H3></A>
<PRE>   This library works by reading a cycle (AKA science record) of EDBs 0-59
   plus and HDB from the open data file into static memory.  Users then 
   read items out of this static memory with data access functions.  (Note:
   for operational reasons, each reading of a cycle actually reads the
   next two EDBs from the next cycle as well, because they contain data
   which was accumulated during the current cycle.)

   Here is a somewhat detailed description of how that is done:
   
   After opening a file with smsOpenFile, a call to smsReadCycle sets
   a chain of events in motion.  First, a data record is read from the
   file.  This record is then scanned for H/EDB identifiers.  When H/EDB
   identifiers are found, the H/EDB is assembled from the subsequent
   subframes.

   As each H/EDB is returned to smsReadCycle, what happens to it
   depends on which it is: For EDBs, it is put into a data structure
   which breaks out the parts of the EDB according to the DPU manual.
   Its header is decoded and saved.  This is the tricky part because
   EDBs vary based on the number of PHA words formatted for each
   instrument.  For HDBs, they are decoded (in part) into a structure.

   When the record has been processed, another is read, being careful to deal
   properly with H/EDBs that span records.

   Once a complete cycle has been accumulated, smsReadCycle returns to the 
   user's calling program and the user may use the data access functions
   to read this data out.

  

</PRE>
<A name="s1_2_">
<H3>1.2. Function Names</H3></A>
<PRE>   Unfortunately, at first glance the function names appear cryptic.  However,
   efforts were made to make them at least partially systematic.  Hopefully,
   that system will be reasonably clear after reading the following principles
   used for naming:

   sms -- all user functions in the library start with this sequence.
          The instrument group is actually referred to as SMS in a number of
	  engineering documents making this a good identifier.
          It stands for SWICS MASS STICS if that isn't obvious.

   All user-level data access routines follow the following scheme:
   sms[g,s,c,d][x,t,m]name[ending]

   sms -- (see above)
   g, s, c, or d -- describes type of function
     g -- get
     s -- set
     c -- convert
     d -- dump (print a bunch of stuff)
   x, t, or m -- instrument ID
     x -- SWICS
     t -- STICS
     m -- MASS
   name -- a name which closely matches the name in the DPU manual (big blue
           book); looking at the description for individual functions should
           make this name pretty clear
   ending -- some functions have endings which follow a pattern
     tab -- table; often used even if only one element is returned
     s -- functions that return a string end in s, e.g. smsgtimes 
          (get time string)
  

</PRE>
<A name="s1_3_">
<H3>1.3. SMS Return Codes</H3></A>
<PRE>   Many of the global funtions return SMS return codes.  Unfortunately,the 
   return codes  are not currently defined in perl.  (Hopefully there will
   be pre-defined perl variables with these names in a future release.  For now
   you'll have to either hard code in the numbers or define your own variables
   and store the values below in them.

   Here are the return codes:
   SMSSUCCESS = 0, no problems
   SMSEOF = -1, end-of-file was found
   SMSERROR = 1, there was a non-fatal error 
   SMSFATAL = 128, there was a fatal error   

</PRE>
<A name="s1_4_">
<H3>1.4. Messages</H3></A>
<PRE>   

   There are two main types of messages written to stdout by libsms:
   1) informational messages that do not indicate any problem 2)
   messages that indicate a (potential) problem.

   For informational messages, the volume and types are controllable
   by the user.  See smssetdbg and smssettrace.

   Messages indicating a (potential) problem are always preceeded by one
   of the following:  warning, error or fatal.  

   Warning messages are produced when the software finds what it knows
   to be a non-standard condition.  This condition may or may not
   indicate a problem; that is up to the user to decide.  (If this
   condition were a known problem, the message would be tagged error or
   fatal.)  These messages are controlled (to some extent) by smssetdbg
   and smssettrace.

   Error messages are usually produced when the library encounters a situation
   that it knows is not right but that is not fatal.  It usually also
   indicates a condition that will not be handled correctly but some
   useful data may still result.

   Fatal error messages are just that: fatal.  They indicate a problem that 
   will prevent any useful data from being accessible and often cause routines
   to exit immediately.

  

</PRE>
<A name="s2_">
<HR><H2>2. Typical Perl Usage</H2></A>
<PRE>   
# open file
$result = libsms::smsOpenFile();

# set debug parameters
libsms::smssetdbg(0);
libsms::smssettrace(0);

# read cycles
$ncycle = 0;
while (libsms::smsReadCycle() = 0) {
  ncycle++;

  # get time of cycle 
  printf(&quot;%s: cycle time in seconds is %d\n&quot;,$thisprog,libsms::smsgtime()); 

  # get time string for cycle
  printf(&quot;%s: Cycle[%3.3d] time is %s\n&quot;,$thisprog,$ncycle,
         libsms::smsgtimes()); 
  
  # write info commuted over many HDBs into memory for later retrieval
  if ($ncycle == 1) {
    libsms::smsDecommHDB();
  }

  for ($nedb=0; $nedb &lt; 60; $nedb++) {

    printf(&quot;%s: EDB[%2.2d] - tnpha=%d\n&quot;,$thisprog,$nedb,
           libsms::smsgtnpha($nedb));
      
    # STICS rates 
    printf(&quot;%s: &quot;,$thisprog);
    for ($j = 0; $j &lt; 3; $j++) {
      printf(&quot;tfsr[%1.1d]=%3.3d &quot;,$j,libsms::smsgtfsr($nedb,$j));
    }
    printf(&quot;\n&quot;);

    # DPPS step
    printf(&quot;%s: &quot;,$thisprog);
    printf(&quot;tDVS[%2.2d]=%2.2d &quot;,$nedb,libsms::smsgtdvs($nedb));
    printf(&quot;\n&quot;);
      
  }
}
libsms::smsCloseFile();
  

</PRE>
<A name="s3_">
<HR><H2>3. Global functions</H2></A>
<P><TT><B>smsOpenFile(char *);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Opens data file, returns one of the SMS return codes.   
</BLOCKQUOTE>

<P><TT><B>smsCloseFile();</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Closes open data file, returning SMSSUCCESS (see above) if no problems
   were encountered.  Prints warning if it encounters a write error.   
</BLOCKQUOTE>

<P><TT><B>smsReadCycle();</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Read one complete cycle from already open data file; incomplete cycles are
   skipped over.  Setting smssettrace(1) causes messages to be output as 
   each cycle is assembled, both complete and incomplete.   
</BLOCKQUOTE>

<P><TT><B>smsDecommHDB();</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Decommute HDB: read a set of 64 HDBs from the file.  This is used for the
   measured voltage tables as well as other things.  Note: this behaves 
   strangely if it is run for each cycle (which shouldn't need to be done 
   usually)   
</BLOCKQUOTE>

<P><TT><B>smsDecompress(byte,fIsCodeC);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Decompress byte -- only needed if you are dealing with raw TM values; rates
   and such are already decompressed.  fIsCodeC is true when decompression
   according to code C is to be used; false uses code A   
</BLOCKQUOTE>

<P><TT><B>smssetdbg(i);</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
Set libsms debug level to i.  The various values give different amounts
of output:
level 0 -- no debugging output
level 1 -- minimal debugging output, 
level 2 -- adds more debugging output (not currently well defined)
level 3 -- adds output of each H/EDB is found in record (lots of output)
level 4 -- adds dumping of H/EDBs -- huge volume of output   
</PRE></BLOCKQUOTE>

<P><TT><B>smssettrace(i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Set trace flag for libsms; setting to TRUE (1) allows more careful tracking
   of the data through the processing   
</BLOCKQUOTE>

<P><TT><B>smsgtime();</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get time for cycle in msec of day.  This is the time from the data record
   header for the first EDB in the cycle.  Time for an individual EDB can be
   approximated by assuming 3s for each EDB.   
</BLOCKQUOTE>

<P><TT><B>smsgtimes();</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Same as above but returns string of time converted into YYYYDOY HH:MM:SS
   (msec usec) suitable for printing   
</BLOCKQUOTE>

<P><TT><B>smsgyear();</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Returns year of cycle; see description for smsgtime()   
</BLOCKQUOTE>

<P><TT><B>smsgdoy();</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Returns year of cycle; see description for smsgtime()   
</BLOCKQUOTE>

<P><TT><B>smsghms();</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Get hours minutes seconds (hms) -- returns  hh:mm:ss of current cycle   
</BLOCKQUOTE>

<P><TT><B>smsgss1970();</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get seconds since 1970 -- returns cycle time in seconds since 1970   
</BLOCKQUOTE>

<P><TT><B>smsdedbhdr(int );</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Dump edb header (for debugging)   
</BLOCKQUOTE>

<P><TT><B>smsgscirec();</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get science record counter (from HDB) of current cycle.  This counter is
 a unique number for each HDB (and associated EDBs of the science record 
(AKA cycle).    
</BLOCKQUOTE>

<P><TT><B>smsgrevcount(nedb);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Get revolution spin counter from EDB[nedb] -- This the is low byte of this 
   counter.  It is found in EDB byte 4.   
</BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. Specific instrument functions</H2></A>
<A name="s4_1_">
<H3>4.1. SWICS</H3></A>
<A name="s4_1_1_">
<H4>4.1.1. engineering rates</H4></A>
<P><TT><B>smsgxfsr(nedb);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get SWICS front SEDA (secondary electron detector assembly) rate for EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgxdvs(nedb);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get SWICS deflection voltage step (DVS; AKA DPPS step) for EDB[nedb]   
</BLOCKQUOTE>

<A name="s4_1_2_">
<H4>4.1.2. PHA words</H4></A>
<P><TT><B>smsgxnpha(nedb);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get SWICS number of PHA words for EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsdxpha(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Dump (print) raw parts of PHA[i] (first is i=0) from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgxenergy(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get SWICS energy of PHA[i] from EDB[nedb] in keV   
</BLOCKQUOTE>

<P><TT><B>smsgxeoq(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get energy / charge (E/Q) of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgxtof(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Does not currently work -- Get SWICS TOF (in physical units of ns) of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgxessd(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Does not currently work -- Get SWICS energy at SSD in keV of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgxmass(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Does not currently work -- Get SWICS mass in amu PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgxmoq(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Does not currently work -- Get SWICS mass/charge in amu PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<A name="s4_2_">
<H3>4.2. STICS</H3></A>
  *******  
   STICS   
  *******  

<A name="s4_2_1_">
<H4>4.2.1. decommuted HDB items</H4></A>
<P><TT><B>smsgtmpvtab(i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   get STICS measured positive voltage table (volts), element i   
</BLOCKQUOTE>

<P><TT><B>smsgtmpvtab_raw(i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   get STICS measured positive voltage table (raw), element i   
</BLOCKQUOTE>

<P><TT><B>smsgtmnvtab(i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   get STICS measured negative voltage table, element i   
</BLOCKQUOTE>

<P><TT><B>smsgtmnvtab_raw(i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   get STICS measured negative voltage table (raw), element i   
</BLOCKQUOTE>

<A name="s4_2_2_">
<H4>4.2.2. non-engineering rates</H4></A>
<P><TT><B>smsgthmr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS high resolution matrix rates, EDB[nedb], element i   
</BLOCKQUOTE>

<P><TT><B>smsgtsmr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS sector matrix rates, EDB[nedb], element i   
</BLOCKQUOTE>

<P><TT><B>smsgtbr0(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS basic rates BR0, EDB[nedb], element i   
</BLOCKQUOTE>

<P><TT><B>smsgtbr1(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS basic rates BR1, EDB[nedb], element i   
</BLOCKQUOTE>

<P><TT><B>smsgtbr2(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS basic rates BR2, EDB[nedb], element i   
</BLOCKQUOTE>

<P><TT><B>smsgtomr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS omnidirectional matrix rates, EDB[nedb], element i   
</BLOCKQUOTE>

<A name="s4_2_3_">
<H4>4.2.3. engineering rates</H4></A>
<P><TT><B>smsgtfsr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS front SEDA rate for detector i, EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtrsr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS rear SEDA rate for detector i, EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtdcr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS double coincidence rate for detector i, EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgttcr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS triple coincidence rate for detector i, EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtssd(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS solid state detector rate for detector i, EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtdvs(nedb);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Get STICS deflection voltage step (DVS; AKA DPPS step) for EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtdvstab(i);</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
Get STICS deflection voltage step table (dvstab), element i (0 &lt;= i &lt;= 59)

Method: This gets a dvs sequence from the current cycle THE FIRST TIME
IT IS CALLED.  Subsequent calls simply read that table out of static memory.
It resets itself when a new file is opened.  Therefore, you should be sure
to call this routine once (with any legal argument) before you exit an
smsReadCycle loop.  If this is done, this function will always return a 
valid stepping table. 

Note 1:  This DOES NOT do checks to be sure that this table does not change 
during the reading of the file. If what you want is a dvs table from the
current cycle, do something like this:  

for ($i = 0; $i &lt; 60; $i++){
  $dvstab[$i] = smsgtdvs(i)
} 

just after a call to smsReadCycle.

Note 2:  If you want an e/q table, see smsgteqtab.

</PRE></BLOCKQUOTE>

<P><TT><B>smsgtmode(nedb);</B></TT>
<BLOCKQUOTE><PRE>[ returns int  ]
Get diagnostic mode id. for EDB[nedb] 
T ==&gt; diagnostic mode ; F ==&gt; Normal mode.  
When in diagnostic mode some rates are moved around in the following way:  
smsgtomr(11) returns FSR 1
smsgtomr(12) returns FSR 2
smsgtomr(13) returns FSR 3
smsgtomr(14) returns FSR 4
smsgtomr(15) returns FSR 5
smsgtomr(16) returns FSR 6
smsgtomr(17) returns UFSR
smsgtomr(18) returns URSR
smsgtomr(19) returns MFSR
smsgtfsr(1)  returns MRSR
smsgtfsr(2)  returns MPF
smsgtfsr(3)  returns MPR

</PRE></BLOCKQUOTE>

<P><TT><B>smsgtmodes(nedb);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Get diagnostic mode identifier string, string version of smsgtmode.
   Returns 'Normal' and 'Diagnostic'.   
</BLOCKQUOTE>

<A name="s4_2_4_">
<H4>4.2.4. STICS PHA</H4></A>
<P><TT><B>smsgtnpha(nedb);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Get number pha of words from EDB[nedb]  
</BLOCKQUOTE>

<P><TT><B>smsdtpha(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Dump (print) raw parts of PHA[i] (first is i=0) from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtstopid(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS stop Id of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgted(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS energy (digital but decompressed from PHA) of PHA[i] 
   from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtsector(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS sector of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtssdid(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS SSD ID of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgttofd(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS time of flight (digital; straight from PHA) of PHA[i] 
   from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtstart(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS start anode of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtrange(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get STICS range of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgteoq(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get energy / charge (E/Q) of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgttof(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get TOF (in physical units of ns) of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtessd(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get energy at SSD in keV of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtmass(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get mass in amu of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtmoq(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get mass/charge in amu of PHA[i] from EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgtnm(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Get STICS NM (mass classification bin) number for EDB[nedb] PHA[i] --
   The mass part of the M-M/Q space is divided into 58 bins which are
   logarithmically spaced.  The bins are calculated by 
   mass{lower bound of Nm in amu} = 0.5*km^(Nm - 1) with 
   km = (95.0/0.5)^1/58 .  Nm = 0 for mass zero events.    
</BLOCKQUOTE>

<P><TT><B>smsgtnq(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Get STICS NQ (mass/charge classification bin) number for EDB[nedb] PHA[i] --
   The mass/charge part of the M-M/Q space is divided into 126 bins which are
   logarithmically spaced.  The bins are calculated by 
   M/Q{lower bound of Nq in amu/e} = 0.5*kq^(Nq - 1) with 
   km = (42.0/0.9)^1/126 .  Nm = 0 for mass zero events.    
</BLOCKQUOTE>

<P><TT><B>smsgteqtab(i);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Get STICS energy/charge table (eqtab), element i.  NOTE: This just uses
   smsgtdvstab and smsctdvs2eq.   
</BLOCKQUOTE>

<P><TT><B>smsctdvs2eq(dvs);</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   Convert STICS  deflection voltage step (dvs) to energy/charge.
   Note: This is the same energy/charge calculation as smsmgteoq uses 
   (but that one inserts the particular DVS for the PHA word in question).   
</BLOCKQUOTE>

<A name="s4_3_">
<H3>4.3. MASS</H3></A>
<A name="s4_3_1_">
<H4>4.3.1. engineering rates</H4></A>
<P><TT><B>smsgmfsr(nedb,i);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get MASS front SEDA (secondary electron detector assembly) rate i from
   EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgmfsrb(nedb);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get MASS front SEDA rate B, EDB[nedb]   
</BLOCKQUOTE>

<P><TT><B>smsgmdvs(nedb);</B></TT>
<BLOCKQUOTE>[ returns long  ]
<BR>   Get mass deflection voltage step (DVS; aka DPPS step) from EDB[nedb]   
</BLOCKQUOTE>

<A name="s4_3_2_">
<H4>4.3.2. PHA words</H4></A>
<P><TT><B>smsgmnpha(nedb);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   Get MASS number of pha words from EDB[nedb]  
</BLOCKQUOTE>


</BODY>
</HTML>
