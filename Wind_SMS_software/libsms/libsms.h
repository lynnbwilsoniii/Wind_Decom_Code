/** \file libsms.h
 * \brief General header file for libsms
 */
/* file: libsms.h -- General header file for libsms
   Author: Jim Raines (jraines)
   Created: 22Oct99

   Notes:
   1. The use of unsigned variables is necessary for correct importing of 
      telemetry characters.

   2. The comments containing "libsms-h2i" mark beginnings (-begin) and
      ends (-end) of sections to be automatedly put in libsms.i by 
      libsms-h2i.pl .  (The file libsms.i is the definition file for SWIG.)
      Also, comments with %word are SWIG directives, mostly for SWIG's
      automatic documentation generation.

   3. 22Nov2005 - jahf - Documentation has been converted to
   doxygen. The file 'src/libsmsdocs.config' is the doxygen
   configuration file. Compile/update documenation by doing 'doxygen
   libsmsdocs.config'. The documentation is created in the 'src/html/'
   directory. (I converted to doxygen for the documentation because
   the -html option of swig is now deprecated.)
*/

/* libsms-h2i-begin */
/* This perl 5 interface to libsms was generated by SWIG. */
/* %module libsms */
/* libsms-h2i-end */

#include <stdio.h>
#include <math.h>
 
/* define logicals for ease of use 
   (change to enum boolean { FALSE = 0, TRUE = 1 }; */
#define TRUE 1     /**< boolean TRUE, for flags */
#define FALSE 0    /**< boolean FALSE, for flags */

/* set debug level and trace flag.  See smssdbg and smsstrace for levels. */
/** Global debug level */
#define DEBUG gDbgLvl    /* FIX: temp. to avoid changing in all files */
/** Global trace level set to display trace messages */
#define TRACE gTrace     /* FIX: temp. to avoid changing in all files */
#define INITGDBGLVL 0    /**< initial value of gDbgLvl, set in smsOpenFile */
#define INITGTRACE FALSE   /**< initial value of gTrace, set in smsOpenFile */

/* some library-wide maximums */
#define MAXDATA 11000    /**< max size of record */
#define MAXFILENAME 256  /**< max char in filename */

/* libsms-h2i-begin %{ */
/* Enumerations */
/** Return values -- they are increasing integers starting at -1 */
enum libsmsReturnCodes {
  SMSEOF = -1, /* returned when end-of-file is reached */
  SMSSUCCESS = 0, /* successful completion */
  SMSERROR = 1,   /* non-fatal error -- will fix later */
  SMSFATAL = 128 /* fatal error -- causes exit */
};
/** EDB Quality flags -- see smsgedbqual() for more details on effects of each. */
enum EDBQuality {
  EQBADPLUS1 = 1, /* bit 0 is set; nedb + 1 is bad */
  EQBADPLUS2 = 2, /* bit 1 is set; nedb + 2 is bad */
  EQBADTCORE = 4, /* bit 2 is set; STICS core is bad */
  EQMIXEDBRC = 32, /* bit 5 is set; there are both high and low bit rate modes in cycle */
  EQALLSUS = 64,  /* bit 6 is set; all EDB suspect */
  EQALLBAD = 128 /* bit 7 is set; whole EDB is bad */
};
/** These represent the bits that are set in each of the above flags */
enum EDBQualityBits {
  EQBADPLUS1bit = 0, /* bit 0 */
  EQBADPLUS2bit = 1, /* bit 1 */
  EQBADTCOREbit = 2, /* bit 2 */
  EQMIXEDBRCbit = 5,   /* bit 5 */
  EQALLSUSbit = 6,  /* bit 6 */
  EQALLBADbit = 7 /* bit 7 */
};
/* libsms-h2i-end }% */ 

/** Define 'BYTE' to be an unsigned char */
#define BYTE unsigned char

/** for TM integers; use this type so that it could in principle be redefined to a fraction of a short if a short were to get longer (as per Dave Gell's suggestion) */
#define WORD unsigned short int

/*****************************************************************************/
/*			   Data Structures                                   */
/*****************************************************************************/
/* These are, as much as possible in the order they are encountered in the 
   record, except, of course, that composite structures follow the definitions
   of their components.
*/

/** \brief File Label Record (FLR) */
typedef struct flr {
  int iScId; /**< spacecraft ID (WIND=25) */
  int iMajFrameInFile;  /**< number of major frames in file */
  int iBytesPerRec; /**< number of bytes per record */
} FLR;

/** \brief Data Record Header (DRH) */
typedef struct drh {
  int iInstNum; /**< instrument number */
  int iTmMode; /**< telemetry mode indicator */
  char abTmMode[16]; /**< telemetry mode name */

  /* ATC:member -- Beginning of Major Frame */
  long year; /**< ATC:year */
  long day;  /**< ATC:day */
  long msec; /* etc. */
  long usec;
  long hour;
  long min;
  long sec;

} DRH;

/*********************************/
/* experimental data block (EDB) */
/*********************************/

/** \brief EDB header -- decoded */
typedef struct edbheader_dc {
  /* 
     declarations are grouped by byte, e.g. numsf, is_edb, sfbytes and 
     highbitrate are all derived from byte 2

     Values listed as T/F can have values 1/0, resp. and are all named
     with a preceeding 'f' (for boolean flag) and often with mixed 
     capitalization to split words/syllables.

     The names are often based as closely as practical on the SMS DPU manual.

     NOTE: Updates to structure must also include 
     1. updating dim. of 'members' (below)
     2. updating list of members in function decodeEDBheader
     3. updating list
  */


  /* structure stuff  */
  char *members[31]; /**< 31 is number of members - 2 */
  int nmembers; /**< Number of data objects in the header (31, unless structure ever changes) */
  
  //@{ \name byte 2
  int numsf; /**< number of subframes in EDB */
  int fIsEDB; /**< type of DB; 0 ==> EDB, 1 ==> HDB */
  int sfbytes; /**< number of bytes per subframe, 37 or 40 */
  int fHighBitrate; /**< 1 ==> high bit rate mode, 0 ==> low bit rate mode */
  //@}

  //@{ \name byte 3
  int fMPresent; /**< T/F, is Mass sensor present? */
  int fRamCheckStat; /**< T/F, 1 ==> instrument in RAM check mode */
  int msn; /**< measurement spin number, 0-59.  labels number of EDB in cycle */
  //@}

  //@{ \name byte 4
  int revcount; /**< revolution counter (low byte only) */
  //@}

  //@{ \name byte 5
  int xnpha; /**< number of SWICS PHA words, 255 ==> sensor off */
  //@}

  //@{ \name byte 6
  int tnpha; /**< number of STICS PHA words, 255 ==> sensor off */
  //@}

  //@{ \name byte 7
  int fValidCom; /**< valid [DPU(?)] command */
  int fComSemErr; /**< command semantic error */
  int fComSynErr; /**< command syntax error */
  int fMCovPowOn; /**< MASS cover power on */
  int fXHeatPowOn; /**< SWICS heater power on */
  int fXCovPowOn; /**< SWICS  cover power on */
  int fTHeatPowOn; /**< STICS heater power on */
  int fTCovPowOn; /**< STICS cover power on */
  //@}

  //@{ \name bytes 8 and 9
  int mnpha; /**< number of MASS PHA words */
  int fMDischargeB; /**< MASS Discharge B indicator */
  int fRuntimeErr; /**< runtime error */
  int fXDAPSdischarge; /**< SWICS DAPS discharge */
  int RemProcTime; /**< remaining processor time per spin */
  //@}

  //@{ \name byte 10
  int fMHPSstpflg; /**< MASS HPS stepping flag */
  int fMSPMCPstpflg; /**< MASS stop MCP stepping flag */
  int fMSTMCPstpflg; /**< MASS start MCP stepping flag */
  int fXPAPSstpflg; /**< SWICS PAPS stepping flag */
  int fXSPMCPstpflg; /**< SWICS stop MCP stepping flag */
  int fXSTMCPstpflg; /**< MASS start MCP  stepping flag */
  int fTMCP3456stpflg; /**< STICS MCP (3, 4, 5 or 6) stepping flag */
  int fTMCP012stpflg; /**< STICS MCP (0, 1 or 2)  stepping flag */
  //@}
} EDB_H_DC;  


/** \brief raw, high bit rate mode */
typedef struct edb_raw_high {
  //@{ \name EDB header
  BYTE h[11];
  //@}

  //@{ \name SWICS(X) core area -- 116 bytes */
  BYTE xbr0[16];
  BYTE xbr1[16];
  BYTE xbr2a[16];
  BYTE xbr2b[16];
  BYTE xbr2c[16];
  BYTE xmr[21];
  BYTE xme[8];
  BYTE xfsr;
  BYTE xdcr;
  BYTE xtcr;
  BYTE xssd[3];
  BYTE xhk;
  //@}

  //@{ \name SWICS PHA Words, sized for maximum */
  /** 168 words * 4 bytes/word (see page 291 in DPU manual) */
  BYTE xpha[672];
  //@}

  //@{ \name STICS core area -- 180 bytes
  BYTE thmr[96];
  BYTE tsmr[24];
  BYTE tbr0[8];
  BYTE tbr1[8];
  BYTE tbr2[8];
  BYTE tomr[20];
  BYTE tfsr[3];
  BYTE trsr[3];
  BYTE tdcr[3];
  BYTE ttcr[3];
  BYTE tssd[3];
  BYTE thk;
  //@}

  //@{ \name STICS PHA Words, sized for maximum
  /** 152 words * 4 bytes/word (see page 291 in DPU manual) */
  BYTE tpha[608];
  //@}

  //@{ \name MASS core area -- 27 bytes
  BYTE mfsr[2]; /* unsectored engineering rates */
  BYTE mfsrb;
  BYTE mmdcr;
  BYTE mufsr_s; /* sectored engineering rates */
  BYTE mufsr_ns;
  BYTE mrsr_s;
  BYTE mrsr_ns;
  BYTE mdcr_s;
  BYTE mdcr_ns;
  BYTE mmfsr;
  BYTE mbr0_s;
  BYTE mbr0_ns;
  BYTE mbr1_s;
  BYTE mbr1_ns;
  BYTE mmr[10];
  BYTE mhk;
  //@}

  //@{ MASS PHA Words, sized for maximum
  /** 381 words * 2 bytes/word (see page 291 in DPU manual) */
  BYTE mpha[762];
  //@}

} EDB_R_H;

/** \brief raw, low bit rate mode */
typedef struct edb_raw_low {
  //@{ \name EDB header
  BYTE h[11];
  //@}

  //@{ \name SWICS core area -- 62 bytes
  BYTE xbr0[8];
  BYTE xbr1[8];
  BYTE xbr2x[8];
  BYTE xbr2y;
  BYTE xbr2z;
  BYTE xmr[21];
  BYTE xme[8]; /* commuted! */
  BYTE xfsr;
  BYTE xdcr;
  BYTE xtcr;
  BYTE xssd[3];
  BYTE xhk;
  //@}

  //@{ \name SWICS PHA Words, sized for maximum
  /** 81 words * 4 bytes/word (see page 291 in DPU manual) */
  BYTE xpha[324];
  //@}

  //@{ \name STICS core area -- 90 bytes (180 bytes commutted over 2 edb)
  BYTE thmr[96];
  BYTE tsmr[24];
  BYTE tbr0[8];
  BYTE tbr1[8];
  BYTE tbr2[8];
  BYTE tomr[20];
  BYTE tfsr[3];
  BYTE trsr[3];
  BYTE tdcr[3];
  BYTE ttcr[3];
  BYTE tssd[3];
  BYTE thk;
  //@}

  //@{ \name STICS PHA Words, sized for maximum
  /** 74 words * 4 bytes/word (see page 291 in DPU manual) */
  BYTE tpha[296];
  //@}

  //@{ \name MASS core area -- 27 bytes
  BYTE mfsr[2]; /* unsectored engineering rates */
  BYTE mfsrb;
  BYTE mmdcr;
  BYTE mufsr_s; /* sectored engineering rates */
  BYTE mufsr_ns;
  BYTE mrsr_s;
  BYTE mrsr_ns;
  BYTE mdcr_s;
  BYTE mdcr_ns;
  BYTE mmfsr;
  BYTE mbr0_s; /* basic rates */
  BYTE mbr0_ns;
  BYTE mbr1_s;
  BYTE mbr1_ns;
  BYTE mmr[10]; /* matrix rates */
  BYTE mhk;
  //@}

  //@{ \name MASS PHA Words, sized for maximum
  /** 181 words * 2 bytes/word (see page 291 in DPU manual) */
  BYTE mpha[362];
  //@}

} EDB_R_L;

#define EDB EDB_R_L  /**< temporarily for convenience */

/** \brief decoded SWICS PHA word */
typedef struct xpha {
  /* in order from low bit to high bit */
  int sector; /**< sector */
  int energy; /**< energy */
  int range; /**< range */
  int ssdId; /**< solid state detector ID */
  int tof; /**< time of flight */

  char ssdName[5]; /**< name of detector */

  /* decoded items */

  /* calculated quantities (in physical units) */
  double eoq; /**< energy/charge */
  double tofns; /**< time of flight in ns */
  double energykev; /**< energy in keV */
  double mass; /**< mass */
  double moq; /**< mass/charge */

} XPHA;

/** \brief decoded STICS PHA word */
typedef struct tpha {
  /* in order from low bit to high bit */
  int stopId; /**< stop ID */
  int startIdRng; /**< start anode and range combined */
  int energy; /**< energy */
  int sector; /**< sector */
  int ssdId; /**< solid state detector ID */
  int tof; /**< time of flight */

  char ssdName[5]; /**< name of detector */

  /* decoded items */
  int start; /**< start anode */
  int range; /**< range */

  /* calculated quantities (in physical units) */
  double eeoq; /**< empirical energy/charge */
  double eoq; /**< energy/charge */
  double tofns; /**< time of flight in ns */
  double energykev; /**< energy in keV */
  double mass; /**< mass */
  double moq; /**< mass/charge */

  double nm; /**< number of the mass bin for this word */
  double nq; /**< number of the mass/charge bin for this word */
} TPHA;

/** \brief decoded MASS PHA word */
typedef struct mpha {
  /* in order from low bit to high bit */
  int sector; /**< sector. 0=non sun sector; 1=sun sector */
  int range;  /**< range. 0=range 0; 1=range 1 */
  int anode;  /**< anode. 0=invalid; 1=Start MCP (Anode 1); 2=Stop MCP
		 (Anode 2; 3=Start and Stop MCP */
  int tof; /**< time of flight */

  /* calculated quantities (in physical units) */
  double tofns; /**< time of flight in ns */
  double mass; /**< mass */
  double moq; /**< mass/charge */
} MPHA;


/*********************************/
/** \brief housekeeping data block (HDB) 
 * (280 bytes in science mode; 231 bytes in maneuver mode)
 */
/*********************************/
typedef struct hdb { 

  /** raw hdb bytes */
  BYTE r[280]; 

  /** decoded hdb stuff */
  WORD SciRecCount;  /* science record counter; unique (at least for months)*/

  int NumHDB; /**< number of this HDB in set of 64 -- for commutated values */

  int tmpDPPShv; /**< STICS measured + DPPS High Voltage */
  int tmnDPPShv; /**< STICS measured - DPPS High Voltage */

  //@{ \name compression groups
  int tCompGrp1; /**< STICS compression group 1 -- 0 ==> type A, 1 ==> type C */
  int tCompGrp2; /**< STICS compression group 2 -- 0 ==> type A, 1 ==> type C */
  int xCompGrp1; /**< SWICS compression group 1 -- 0 ==> type A, 1 ==> type C */
  int xCompGrp2; /**< SWICS compression group 2 -- 0 ==> type A, 1 ==> type C */
  int mCompGrp1; /**< MASS  compression group 1 -- 0 ==> type A, 1 ==> type C */
  int mCompGrp2; /**< MASS  compression group 2 -- 0 ==> type A, 1 ==> type C */
  //@}
} HDB;

/** \brief Decommuted HDB -- contains misc. decommuted values from HDB */
typedef struct decomm_hdb {

  //@{ \name STICS stepping tables -- element x is for step x
  int tMeasPosStepTab_Raw[64]; /**< STICS measured positive step table (raw) */
  double tMeasPosStepTab[64]; /**< STICS measured positive step table (V)*/

  int tMeasNegStepTab_Raw[64]; /**< STICS measured negative step table (raw) */
  double tMeasNegStepTab[64]; /**< STICS measured negative step table (V)*/
  //@}

  //@{ \name MASS stepping tables -- element x is for step x
  int mMeasStepTab_Raw[64]; /**< MASS measured (DPPS) step table (raw) */
  double mMeasStepTab[64]; /**< MASS measured (DPPS) step table (V) */
  //@}

  //@{ \name
  BYTE FredString[80]; /**< phrase which ensures a complete set of 64 HDBs have
			  been found */
  //@}
} DECOMM_HDB;

/** \brief cycle */
typedef struct cycle {
  EDB_R_L edb[62]; /**< 60 EDB's per cycle (0-59) + 2 extra for fixReadoutDelay*/
  EDB_R_H edb_r_h[62]; /**< IN HIGH BIT RATE MODE */
  HDB hdb;         /**< 1 HDB */
  EDB_H_DC h_dc[62]; /**< decoded EDB headers */
  DECOMM_HDB decomm_hdb; /**< decommuted HDB values */
  DRH drh;         /**< data record header from *beginning* of cycle */
  short EDBQuality[62]; /**< EDB quality flag for these EDBs */
  BYTE CHK[250][2]; /**< fixed housekeeping data (from last record read) */
  short nedb; /**< number of EDBs in this cycle */
} CYCLE;

/* libsms-h2i-begin */
/*****************************************************************************/
/*		 Perl Interface General Documentation                        */
/*****************************************************************************/
/** \mainpage libsms Documentation
 *
 * \section general General Information
 * \subsection intro Introduction
 This library works by reading a cycle (AKA science record) of EDBs
   0-59 plus an HDB from the open data file into static memory.  Users
   then read items out of this static memory with data access
   functions.  (Note: Each reading of a cycle actually reads the next
   two EDBs from the next cycle as well, because they contain data
   which was accumulated during the current cycle.)

   Here is a somewhat detailed description of how that is done:
   
   After opening a file with smsOpenFile, a call to smsReadCycle sets
   a chain of events in motion.  First, a data record is read from the
   file.  This record is then scanned for H/EDB identifiers.  When H/EDB
   identifiers are found, the H/EDB is assembled from the subsequent
   subframes.

   As each H/EDB is returned to smsReadCycle, what happens to it
   depends on which it is: For EDBs, it is put into a data structure
   which breaks out the parts of the EDB according to the DPU manual.
   Its header is decoded and saved.  This is the tricky part because
   EDBs vary based on the number of PHA words formatted for each
   instrument.  For HDBs, they are decoded (in part) into a structure.

   When the record has been processed, another is read, being careful to deal
   properly with H/EDBs that span records.

   Once a complete cycle has been accumulated, smsReadCycle returns to the 
   user's calling program and the user may use the data access functions
   to read this data out.

   *
   * \subsection funcnames Function Names
   Unfortunately, at first glance the function names appear cryptic.  However,
   efforts were made to make them at least partially systematic.  Hopefully,
   that system will be reasonably clear after reading the following principles
   used for naming:

   sms -- all user functions in the library start with this sequence.
          The instrument group is actually referred to as SMS in a number of
	  engineering documents making this a good identifier.
          It stands for SWICS MASS STICS if that isn't obvious.

   All user-level data access routines follow the following scheme:
   sms[g,s,c,d][x,t,m]name[ending]

   sms -- (see above) <br>
   g, s, c, or d -- describes type of function <br>
     g -- get <br>
     s -- set <br>
     c -- convert <br>
     d -- dump (print a bunch of stuff) <br>
   x, t, or m -- instrument ID <br>
     x -- SWICS <br>
     t -- STICS <br>
     m -- MASS <br>
   name -- a name which closely matches the name in the DPU manual (big blue
           book); looking at the description for individual functions should
           make this name pretty clear <br>
   ending -- some functions have endings which follow a pattern <br>
     tab -- table; often used even if only one element is returned <br>
     s -- functions that return a string end in s, e.g. smsgtimes 
          (get time string)
   
 * \subsection returncodes SMS Return Codes
 Many of the global funtions return SMS return codes.  Unfortunately,the 
   return codes  are not currently defined in perl.  (Hopefully there will
   be pre-defined perl variables with these names in a future release.  For now
   you'll have to either hard code in the numbers or define your own variables
   and store the values below in them.

   Here are the return codes:

   SMSSUCCESS = 0, no problems <br>
   SMSEOF = -1, end-of-file was found <br>
   SMSERROR = 1, there was a non-fatal error <br> 
   SMSFATAL = 128, there was a fatal error 

 * \subsection outputmessages Messages
 
   There are two main types of messages written to stdout by libsms:
   1) informational messages that do not indicate any problem 2)
   messages that indicate a (potential) problem.

   For informational messages, the volume and types are controllable
   by the user.  See smssdbg and smsstrace.

   Messages indicating a (potential) problem are always preceeded by one
   of the following:  warning, error or fatal.  

   Warning messages are produced when the software finds what it knows
   to be a non-standard condition.  This condition may or may not
   indicate a problem; that is up to the user to decide.  (If this
   condition were a known problem, the message would be tagged error or
   fatal.)  These messages are controlled (to some extent) by smssdbg
   and smsstrace.

   Error messages are usually produced when the library encounters a situation
   that it knows is not right but that is not fatal.  It usually also
   indicates a condition that will not be handled correctly but some
   useful data may still result.

   Fatal error messages are just that: fatal.  They indicate a problem that 
   will prevent any useful data from being accessible and often cause routines
   to exit immediately.


   * \section typicalusage Typical Perl Usage
 
# open file <br>
$file = "/home/winddata/LV1/2001/wi_lz_sms_20010225_v01.dat"; <br>
$result = libsms::smsOpenFile($file);

# set trace to 1 for more verbose output from libsms <br>
libsms::smsstrace(0);

# read cycles <br>
$ncycle = 0; <br>
while (libsms::smsReadCycle() = 0) { <br>
  &nbsp;&nbsp;&nbsp;&nbsp; ncycle++;

  &nbsp;&nbsp;&nbsp;&nbsp; # get time of cycle <br>
  &nbsp;&nbsp;&nbsp;&nbsp; printf("%s: cycle time in seconds is %d\n",$thisprog,libsms::smsgtime()); 

  &nbsp;&nbsp;&nbsp;&nbsp; # get time string for cycle <br>
  &nbsp;&nbsp;&nbsp;&nbsp; printf("%s: Cycle[%3.3d] time is %s\n",$thisprog,$ncycle, libsms::smsgtimes()); 
  
  &nbsp;&nbsp;&nbsp;&nbsp; # write info commuted over many HDBs into memory for later retrieval <br>
  &nbsp;&nbsp;&nbsp;&nbsp; if ($ncycle == 1) { <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; libsms::smsDecommHDB(); <br>
  &nbsp;&nbsp;&nbsp;&nbsp; }

  &nbsp;&nbsp;&nbsp;&nbsp; for ($nedb=0; $nedb < 60; $nedb++) {

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s: EDB[%2.2d] - tnpha=%d\n",$thisprog,$nedb, libsms::smsgtnpha($nedb));
      
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # STICS rates <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s: ",$thisprog); <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ($j = 0; $j < 3; $j++) { <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("tfsr[%1.1d]=%3.3d ",$j,libsms::smsgtfsr($nedb,$j)); <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n");

    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # DPPS step <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("%s: ", $thisprog); <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("tDVS[%2.2d]=%2.2d ",$nedb, libsms::smsgtdvs($nedb)); <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n"); <br>
  &nbsp;&nbsp;&nbsp;&nbsp; } <br>
} <br>
libsms::smsCloseFile();
*/
/* libsms-h2i-end */

/* libsms-h2i-begin */

/*****************************************************************************/
/*			      Prototypes                                     */
/*****************************************************************************/
/* libsms-h2i-end */

//@{ \name Functions - general utility
/** Returns a long int out of a range of bytes (lowbyte to highbyte) from a byte array (data) */
unsigned long lBuildWord(unsigned char *,long int,long int);
double dBuildWord(unsigned char [],long int,long int);
//@}

//@{ \name Functions - Main Cycle Reading Functions

/* libsms-h2i-begin */ 
/** Opens data file, returns one of the SMS return codes. */
int smsOpenFile(char [MAXFILENAME]);

/** Closes open data file, returning SMSSUCCESS if no problems
   were encountered.  Prints warning if it encounters a write error. */
int smsCloseFile();

/** Read one complete cycle from already open data file; incomplete cycles are
   skipped over.  Setting smsstrace(1) causes messages to be output as 
   each cycle is assembled, both complete and incomplete. */
int smsReadCycle();

/** Decommute HDB: read a set of 64 HDBs from the file.  This is used for the
   measured voltage tables as well as other things.  Note: this behaves 
   strangely if it is run for each cycle (which shouldn't need to be done 
   usually) */
int smsDecommHDB();

/** Decompress byte -- only needed if you are dealing with raw TM values; rates
   and such are already decompressed.  fIsCodeC is true when decompression
   according to code C is to be used; false uses code A */
long smsDecompress(unsigned char byte, int fIsCodeC);

/** smsGetBits -- returns bits from lobit to hibit from byte.  (Byte can be
    any type of variable, not only an unsigned char.) */

/*   Examples:

   Note --      
   Decimal 11 is 00001011 in binary (bits 0,1 and 3 are 1's; rest are 0), i.e.,
   bit number 76543210 
   bit value  00001011

   Call           Returns(decimal)  Comment
   ----           ----------------  -------
   getBits(9,0,0) 1 (1)             Returns lowest order bit in 9
   getBits(9,0,2) 011 (3)           011 in binary is decimal 3      
   getBits(9,3,0) 1011 (11)
   getBits(9,4,2) 010 (2)           010 in binary is decimal 2 
   getBits(i,4,7)                   gets bits 4 through 7 from the value stored
                                    in variable i
*/
unsigned smsGetBits(unsigned byte, int lobit,int hibit);

//@}

/****************************************************************************/
/* prototypes for smsTools functions (also perl-accessible libsms functions)*/
/****************************************************************************/

//@{ \name Functions - Flags, Configuration and Quality-Related Functions

/* dealing with whole data */

/** Set libsms debug level to i.  These debug values are primarily for
   use in debugging the actual libsms library.  Thus, they would be
   rarely used by end users.  However, levels 3 and 4 can be very
   useful for determining problems with the data in a particular time
   period, such as corrupted values (telemetry hits) or missing sections.

   The various values give different amounts of output:

   level 0 -- no debugging output <br>
   level 1 -- minimal debugging output <br> 
   level 2 -- adds more debugging output (not currently well defined) <br>
   level 3 -- adds output as each H/EDB is found in record (lots of output) <br>
   level 4 -- adds dumping of H/EDBs -- huge volume of output */
int smssdbg(int i);

/** synonym for smssdbg */
int smssetdbg(int i);

/** Set trace flag for libsms; setting to TRUE (1) allows more careful
   tracking of the data through the processing.  Setting the debug
   value (see smssdbg) 3 or greater causes this flag to be set
   automatically. */
int smsstrace(int i);

/** synonym for smsstrace */
int smssettrace(int i);

/** set incomplete cycle override flag to i.  Default behavior (i=0) of
   smsReadCycle is to drop cycles that do not have a full 62 EDBs (60
   for the cycle plus 2 from the next for readout delay).  Giving this
   function an argument of 1 causes these incomplete cycles to be
   kept.  Note: smssqualover must also be set.  Returns the new value
   of the flag (which may be ignored.)  Use with smsgnedb. */
int smssinccycover(int i);

/** get number of EDBs from current cycle -- This is only needed with
   smssinccycover; other wise there are always 60 EDBs per cycle. */
int smsgnedb();

/** Return whether given EDB from the current cycle is in high or low
   bit rate mode.  All EDBs in a cycle should be the same - if there
   are mixed bit rate mode EDBs within a cycle, they are marked with
   the EQMIXEDBRC flag. Returns 1 for high bit rate mode, 0 for
   low. */
int smsgbitrate(int nedb);

/** set quality override flag.  Default behavior (i=0) of smsReadCycle
   is to drop cycles with at least 1 bad EDB.  Set this to 1 to keep
   cycles with EDBs that are marked bad.  See smsgedbqual.  Returns
   the new value of the flag (which may be ignored.)  Use with
   smsgedbqual.  */
int smssqualover(int i);

/** smsgedbqual -- get EDB quality flag for EDB[nedb].  This is a bit field;
   use getBits to read any bit.  NOTE: Use this only if you have some good 
   reason to want to keep cycles with bad EDBs, i.e. if you need every bit 
   of data collected in a certain time period.  

   Here are the values:

   <table>
   <tr><td> bit </td><td> meaning when set </td></tr>
   <tr><td> 0 </td><td> X: (none of these work anyway!) </td></tr>
   <tr><td> &nbsp; </td><td> T: bad OMR & ER </td></tr>
   <tr><td> &nbsp; </td><td> M: bad MR and spin-oriented ER </td></tr>
   <tr><td> 1 </td><td> X: bad PHA, npha </td></tr>
   <tr><td> &nbsp; </td><td> T: bad PHA, npha, HMR, BR, SMR </td></tr>
   <tr><td> &nbsp; </td><td> M: bad PHA, npha, BR, sector-oriented ER </td></tr>
   <tr><td> 2 </td><td> STICS core area (all rates, DVS, mode flag) is bad.</td></tr>
   <tr><td> 3-5 </td><td> not used </td></tr>
   <tr><td> 6 </td><td> Entire EDB is suspect; This means a problem was found which will have ill-defined effects on the EDB (e.g. npha out of range) </td></tr>
   <tr><td> 7 </td><td> Entire EDB is bad. </td></tr>
   </table>

   Example: skip bad EDBs

   libsms::smssoverqual(1);  # tells smsReadCycle *not* to skip cycles with bad EDBs

   for ($nedb = 0; $nedb < 60; $nedb++){ <br>
     &nbsp;&nbsp;&nbsp;&nbsp;if (getBits(libsms::smsgedbqual(nedb),7,7)){ <br>
      &nbsp;&nbsp;&nbsp;&nbsp;  next;  # skip to next iteration because edb is bad <br>
     }

     # do important stuff with each EDB
   }

*/
int smsgedbqual(int nedb);

/** smsgver -- get version of library, in form major.minor.build */
char *smsgver();

//@}

//@{ \name Functions - Time/Date
/** Get time for cycle in msec of day.  This is the time from the data record
   header for the first EDB in the cycle.  Time for an individual EDB can be
   approximated by assuming 3s for each EDB. */
long smsgtime();

/** Same as above but returns string of time converted into YYYYDOY HH:MM:SS
   (msec usec) suitable for printing */
char *smsgtimes();

/** Returns year of cycle; see description for smsgtime() */
int smsgyear();

/** Returns year of cycle; see description for smsgtime() */
int smsgdoy();

/** Get hours minutes seconds (hms) -- returns  hh:mm:ss of current cycle */
char *smsghms();

/** Get seconds since 1970 -- returns cycle time in seconds since 1970 */
extern double smsgss1970();

/** smsIsLeapYear -- returns 1 if arg. is a leap year, 0 otherwise. */
int smsIsLeapYear(int year);

/** smsIncrementDate -- Increment WIND-style date (yyyymmdd) by one
   day, rolling over months and years if necessary.  Handles leap
   years properly. */
long int smsIncrementDate(long int date);

//@}

//@{ \name Functions - Miscellaneous
/** Dump edb header (for debugging) */
int smsdedbhdr(int);

/** Get science record counter (from HDB) of current cycle.  This counter is
 a unique number for each HDB (and associated EDBs of the science record 
(AKA cycle).  */
long smsgscirec();

/** Get revolution spin counter from EDB[nedb] -- This the is low byte of this 
   counter.  It is found in EDB byte 4. */
int smsgrevcount(int nedb);

//@}

/*********/
/* SWICS */
/*********/

//@{ \name Functions - SWICS

/* engineering rates */
/**********************/

/** Get SWICS front SEDA (secondary electron detector assembly) rate for EDB[nedb] */
long smsgxfsr(int nedb);

/** Get SWICS deflection voltage step (DVS; AKA DPPS step) for EDB[nedb] */
long smsgxdvs(int nedb);

/** Get SWICS deflection voltage step table (dvstab), element i (0 <= i <= 59)
   Method:  Returns 59 - i which is the fixed stepping table for SWICS,
   where i is the EDB number (AKA measurement spin number). */
int smsgxdvstab(int i);

/* PHA words */
/*************/

/** Get SWICS number of PHA words for EDB[nedb] */
long smsgxnpha(int nedb);

/** Dump (print) raw parts of PHA[i] (first is i=0) from EDB[nedb] */ 
int smsdxpha(int nedb, int i);

/** Get SWICS energy of PHA[i] from EDB[nedb] in keV */
extern double smsgxenergy(int nedb, int i);

/** Get energy / charge (E/Q) of PHA[i] from EDB[nedb] */
extern double smsgxeoq(int nedb, int i);

/** Does not currently work -- Get SWICS TOF (in physical units of ns) of PHA[i] from EDB[nedb] */
extern double smsgxtof(int nedb,int i);

/** Does not currently work -- Get SWICS energy at SSD in keV of PHA[i] from EDB[nedb] */
extern double smsgxessd(int nedb, int i);

/** Does not currently work -- Get SWICS mass in amu PHA[i] from EDB[nedb] */
extern double smsgxmass(int nedb, int i);

/** Does not currently work -- Get SWICS mass/charge in amu PHA[i] from EDB[nedb] */
extern double smsgxmoq(int nedb, int i);

/** Get SWICS energy/charge table (eqtab), element i.  NOTE: This just uses
   smsgxdvstab and smscxdvs2eq. */
double smsgxeqtab(int i);

/** Convert SWICS  deflection voltage step (dvs) to energy/charge.

   Note 1: This is the same energy/charge calculation as smsmgxeoq uses 
   (but that one inserts the particular DVS for the PHA word in question).

   Note 2: This is currently a hard-coded look up table and and does not 
   read values from the telemetry.  Values used here were obtained from 
   Alysha Reynard, Feb2000.  (They were calc. from TM originally.)*/
double smscxdvs2eq(int dvs);

//@}

/*********/
/* STICS */
/*********/
//@{ \name Functions - STICS

/* decommuted HDB items */
/************************/

/** get STICS measured positive voltage table (volts), element i */
extern double smsgtmpvtab(int i);

/** get STICS measured positive voltage table (raw), element i */
int smsgtmpvtab_raw(int i);

/** get STICS measured negative voltage table, element i */
double smsgtmnvtab(int i);

/** get STICS measured negative voltage table (raw), element i */
int smsgtmnvtab_raw(int i);

/* non-engineering rates */
/*************************/

/** Get STICS high resolution matrix rates, EDB[nedb], element i */
long smsgthmr(int nedb, int i);

/** Get STICS sector matrix rates, EDB[nedb], element i */
long smsgtsmr(int nedb, int i);

/** Get STICS basic rates BR0, EDB[nedb], element i */
long smsgtbr0(int nedb, int i);

/** Get STICS basic rates BR1, EDB[nedb], element i */
long smsgtbr1(int nedb, int i);

/** Get STICS basic rates BR2, EDB[nedb], element i */
long smsgtbr2(int nedb, int i);

/** Get STICS omnidirectional matrix rates, EDB[nedb], element i */
long smsgtomr(int nedb, int i);

/* engineering rates */
/*********************/

/** Get STICS front SEDA rate for detector i, EDB[nedb] */
long smsgtfsr(int nedb, int i);
/** Get STICS rear SEDA rate for detector i, EDB[nedb] */
long smsgtrsr(int nedb, int i);
/** Get STICS double coincidence rate for detector i, EDB[nedb] */
long smsgtdcr(int nedb, int i);
/** Get STICS triple coincidence rate for detector i, EDB[nedb] */
long smsgttcr(int nedb, int i);
/** Get STICS solid state detector rate for detector i, EDB[nedb] */
long smsgtssd(int nedb, int i);

/** Get STICS deflection voltage step (DVS; AKA DPPS step) for EDB[nedb] */
int smsgtdvs(int nedb);

/** Get STICS deflection voltage step table (dvstab), element i (0 <= i <= 59)

   Method: This gets a dvs sequence from the current cycle THE FIRST TIME
   IT IS CALLED.  Subsequent calls simply read that table out of static memory.
   It resets itself when a new file is opened.  Therefore, you should be sure
   to call this routine once (with any legal argument) before you exit an
   smsReadCycle loop.  If this is done, this function will always return a 
   valid stepping table. 

   Note 1:  This DOES NOT do checks to be sure that this table does not change 
   during the reading of the file. If what you want is a dvs table from the
   current cycle, do something like this:  

   for ($i = 0; $i < 60; $i++){ <br>
     &nbsp;&nbsp;&nbsp;&nbsp;$dvstab[$i] = smsgtdvs(i) <br>
   } 

   just after a call to smsReadCycle.

   Note 2:  If you want an e/q table, see smsgteqtab.
*/
int smsgtdvstab(int i);

/** Get diagnostic mode id. for EDB[nedb] 

   T ==> diagnostic mode ; F ==> Normal mode.  

   When in diagnostic mode some rates are moved around in the following way:  

   smsgtomr(11) returns FSR 1 <br>
   smsgtomr(12) returns FSR 2 <br>
   smsgtomr(13) returns FSR 3 <br>
   smsgtomr(14) returns FSR 4 <br>
   smsgtomr(15) returns FSR 5 <br>
   smsgtomr(16) returns FSR 6 <br>
   smsgtomr(17) returns UFSR <br>
   smsgtomr(18) returns URSR <br>
   smsgtomr(19) returns MFSR <br>
   smsgtfsr(1)  returns MRSR <br>
   smsgtfsr(2)  returns MPF <br>
   smsgtfsr(3)  returns MPR <br>
*/
int smsgtmode(int nedb);

/** Get diagnostic mode identifier string, string version of smsgtmode.
   Returns 'Normal' and 'Diagnostic'. */
char *smsgtmodes(int nedb);

/* PHA Words */
/*************/

/** Get number pha of words from EDB[nedb]*/
int smsgtnpha(int nedb);

/** Dump (print) raw parts of PHA[i] (first is i=0) from EDB[nedb] */ 
int smsdtpha(int nedb, int i);

/** Get STICS stop Id of PHA[i] from EDB[nedb] */
long smsgtstopid(int nedb, int i);

/** Get STICS energy (digital but decompressed from PHA) of PHA[i] 
   from EDB[nedb] */
long smsgted(int nedb, int i);

/** Get STICS sector of PHA[i] from EDB[nedb] */
long smsgtsector(int nedb, int i);

/** Get STICS SSD ID of PHA[i] from EDB[nedb] */
long smsgtssdid(int nedb, int i);

/** Get STICS time of flight (digital; straight from PHA) of PHA[i] 
   from EDB[nedb] */
long smsgttofd(int nedb, int i);

/** Get STICS start anode of PHA[i] from EDB[nedb] */
long smsgtstart(int nedb, int i);

/** Get STICS range of PHA[i] from EDB[nedb] */
long smsgtrange(int nedb, int i);

/** Get energy / charge (E/Q) of PHA[i] from EDB[nedb] */
extern double smsgteoq(int nedb, int i);

/** Get TOF (in physical units of ns) of PHA[i] from EDB[nedb] */
extern double smsgttof(int nedb,int i);

/** Get energy at SSD in keV of PHA[i] from EDB[nedb] */
extern double smsgtessd(int nedb, int i);

/** Get mass in amu of PHA[i] from EDB[nedb] */
extern double smsgtmass(int nedb, int i);

/** Get mass/charge in amu of PHA[i] from EDB[nedb] */
extern double smsgtmoq(int nedb, int i);

/** Get STICS NM (mass classification bin) number for EDB[nedb] PHA[i]
   -- The mass part of the M-M/Q space is divided into 58 bins which
   are logarithmically spaced.  The bins are calculated by mass{lower
   bound of Nm in amu} = 0.5*km^(Nm - 1) with km = (95.0/0.5)^1/58 .
   Nm = 0 for mass zero events.  */
int smsgtnm(int nedb, int i);

/** Get STICS NQ (mass/charge classification bin) number for EDB[nedb]
   PHA[i] -- The mass/charge part of the M-M/Q space is divided into
   126 bins which are logarithmically spaced.  The bins are calculated
   by M/Q{lower bound of Nq in amu/e} = 0.5*kq^(Nq - 1) with km =
   (42.0/0.9)^1/126 .  Nm = 0 for mass zero events.  */
int smsgtnq(int nedb, int i);

/** Get STICS energy/charge table (eqtab), element i.  NOTE: This just uses
   smsgtdvstab and smsctdvs2eq. */
extern double smsgteqtab(int i);

/** Convert STICS  deflection voltage step (dvs) to energy/charge.
   Note: This is the same energy/charge calculation as smsmgteoq uses 
   (but that one inserts the particular DVS for the PHA word in question). */
extern double smsctdvs2eq(int dvs);


/********/
/* MASS */
/********/
//@{ \name Functions - MASS

/* non-engineering rates */
/*************************/

/** get mass matrix rate i -- It is unclear at this time whether these are 
   double coincidence or single.  The rates are as follows:

<table border=1>
  <tr bgcolor='#AAAAAA'><td> i </td><td> Rate </td></tr>
  <tr><td> 0 </td><td> H </td></tr>
  <tr><td> 1 </td><td> He3 </td></tr>
  <tr><td> 2 </td><td> He4 </td></tr>
  <tr><td> 3 </td><td> C </td></tr>
  <tr><td> 4 </td><td> N </td></tr>
  <tr><td> 5 </td><td> O </td></tr>
  <tr><td> 6 </td><td> Ne </td></tr>
  <tr><td> 7 </td><td> Mg </td></tr>
  <tr><td> 8 </td><td> Si </td></tr>
  <tr><td> 9 </td><td> Fe </td></tr>
</table>
*/
/* (non-formatted version of table:)
   i        Rate
   -        ----
   0        H
   1        He3
   2        He4
   3        C
   4        N
   5        O
   6        Ne
   7        Mg
   8        Si
   9        Fe
*/
long smsgmmr(int nedb,int i);

/** get basic rate BR0_S */
long smsgmbr0_s(int nedb);
/** get basic rate BR0_NS */
long smsgmbr0_ns(int nedb);
/** get basic rate BR1_S */
long smsgmbr1_s(int nedb);
/** get basic rate BR1_NS */
long smsgmbr1_ns(int nedb);

/* engineering rates */
/*********************/

/** Get MASS front SEDA (secondary electron detector assembly) rate i from
   EDB[nedb] */
long smsgmfsr(int nedb, int i);

/** Get MASS front SEDA rate B, EDB[nedb] */
long smsgmfsrb(int nedb);

/** Get MASS MDCR */
long smsgmmdcr(int nedb);

/* sectored engineering rates */
/******************************/

/** UFSR_S */
long smsgmufsr_s(int nedb);
/** UFSR_NS */
long smsgmufsr_ns(int nedb);
/** RSR_S */
long smsgmrsr_s(int nedb);
/** RSR_NS */
long smsgmrsr_ns(int nedb);
/** DCR_S */
long smsgmdcr_s(int nedb);
/** DCR_NS */
long smsgmdcr_ns(int nedb);
/** MFSR */
long smsgmmfsr(int nedb);

/** Get mass deflection voltage step (DVS; aka DPPS step) from EDB[nedb] */
long smsgmdvs(int nedb);

/** Get MASS deflection voltage step table (dvstab), element i (0 <= i <= 59)

   Method: This gets a dvs sequence from the current cycle THE FIRST TIME
   IT IS CALLED.  Subsequent calls simply read that table out of static memory.
   It resets itself when a new file is opened.  Therefore, you should be sure
   to call this routine once (with any legal argument) before you exit an
   smsReadCycle loop.  If this is done, this function will always return a 
   valid stepping table. 

   Note 1:  This DOES NOT do checks to be sure that this table does not change 
   during the reading of the file. If what you want is a dvs table from the
   current cycle, do something like this:  

   for ($i = 0; $i < 60; $i++){ <br>
     &nbsp;&nbsp;&nbsp;&nbsp;$dvstab[$i] = smsgmdvs(i) <br>
   } 

   just after a call to smsReadCycle.

   Note 2:  If you want an e/q table, see smsgmeqtab.
*/
int smsgmdvstab(int i);

/** Get MASS calibration mode from housekeeping byte, bit 7 */
int smsgmcalmode(int nedb);

/* PHA words */
/*************/

/** Get MASS number of pha words from EDB[nedb]*/
int smsgmnpha(int nedb);

/** Get MASS energy/charge table (eqtab), element i.  NOTE: This just uses
   smsgmdvstab and smscmdvs2eq.   See smscmdvs2eq for acceptable
   values of source. */
extern double smsgmeqtab(int i, int source);

/** Convert MASS deflection voltage step (dvs) to energy/charge.
   source specifies the source of this information.  source = 1:
   According to the following formula, E/q = 0.5156 *
   1.05135^dvs. source = 2: Values from HDB (commutated over 64 HDBs).
   These were measured in the in the previous science record for the
   same spin.  NOTE: The measured values are not currently converted
   to voltages properly.  Only the raw numbers are returned. */
extern double smscmdvs2eq(int dvs, int source);

/** Get MASS sector of PHA[i] from EDB[nedb] */
extern long smsgmsector(int nedb, int i);

/** Get MASS range of PHA[i] from EDB[nedb] */
extern long smsgmrange(int nedb, int i);

/** Get MASS anode of PHA[i] from EDB[nedb] */
extern long smsgmanode(int nedb, int i);

/** Get MASS tof of PHA[i] from EDB[nedb] */
extern long smsgmtof(int nedb, int i);

/** Get MASS tof in ns of PHA[i] from EDB[nedb] */
extern double smsgmtofns(int nedb, int i);

/** Get MASS mass of PHA[i] from EDB[nedb] */
extern double smsgmmass(int nedb, int i);

/** Get MASS mass per charge of PHA[i] from EDB[nedb] */
extern double smsgmmoq(int nedb, int i);

//@}

/*****************************************************************************/
/*			    Raw Data Items                                   */
/*****************************************************************************/
/* These functions return individual elements from the respective raw
   arrays.  Note: These should only be used when a special need
   precludes using the normal sms functions which give access to the
   formatted data.  See the DPU Manual (Big Blue Book) for the meaning
   of the individual bytes returned with these functions. */

//@{ \name Functions - Raw Data Items

/** get fixed house keeping data, minor frame mf, byte i.
   Call for mf ranging from 0 - 249, i = 17 or 18.  Note: This is
   currently only for the last record read from the file. */
unsigned char smsgchk(int mf, int i);

/** smsghdb -- get housekeeping data block (HDB) byte i.  Call for i ranging
   from 0 - 279 to get all 280 bytes of the HDB. */
unsigned char smsghdb(int i);

/* smsgedb() -- get experimental data block (EDB).  Not yet implemented. */

//@}

/*****************************************************************************
			  Decoded CHK Items
 *****************************************************************************/
/* These are CHK items which have been converted to physical units using the 
   appropriate calibration curves.  Unless otherwise noted, these calibration 
   curves were taken from the following NASA document:
   WIND Command and Telemetry Handbook,
   Final Flight Version, Rev 4.0, October 20, 1994.*/

//@{ \name Functions - Decoded CHK Items

/** smsgdtempsc -- get DPU temperature (spacecraft thermistor) in
   degrees Celcius.  This routine reads CHK0 (via smsgchk(1,17))
   and converts it to temperature through a polynomial fit:

      rTemp = 6.558508E2 - 1.802378E1 * dCHK + 2.133615E-1 * pow(dCHK,2) - 
      1.295112E-3 * pow(dCHK,3) + 3.927925E-6 * pow(dCHK,4) - 
      4.754717E-9 * pow(dCHK,5) ;

       where rTemp is real temperature (in C)
             dCHK is the CHK value used, cast as double precision
	     pow(dCHK,x) is dCHK raised to the power x

   This fit was done in pre-flight calibration.
*/
extern double smsgdtempsc();

/** smsgdtemp -- get DPU temperature in degrees Celcius.  This routine
   reads CHK9 (via smsgchk(31,17)) and converts it to a temperature
   through a polynomial fit:

      rTemp = 1.437601E2 - 3.224279 * dCHK + 4.848285E-2 * pow(dCHK, 2) - 
      4.101237E-4 * pow(dCHK, 3) + 1.682762E-6 * pow(dCHK, 4) - 
      2.660079E-9 * pow(dCHK, 5)


       where rTemp is real temperature (in C)
             dCHK is the CHK value used, cast as double precision
	     pow(dCHK,x) is dCHK raised to the power x

   This fit was done in pre-flight calibration.
*/
extern double smsgdtemp();

/** smsgxaetempsc -- get SWICS AE temperature (spacecraft thermistor)
   in degrees Celcius.  This routine reads CHK1 (via
   smsgchk(3,18)) and converts it to a temperature through a
   polynomial fit.  See smsgdtempsc().

*/
extern double smsgxaetempsc();

/** smsgxssdtemp -- get SWICS SSD temperature (PAPS referenced) in degrees 
   Celcius.  This routine reads CHK29 (via smsgchk(97,18)) and converts it
   to a temperature through a polynomial fit:

      rTemp = 7.886257E1 - 1.848392 * dCHK + 2.143749E-2 * pow(dCHK, 2) -
      1.483171E-4 * pow(dCHK, 3) + 5.149126E-7 * pow(dCHK, 4) - 
      7.140936E-10 * pow(dCHK, 5) ;

       where rTemp is real temperature (in C)
             dCHK is the CHK value used, cast as double precision
	     pow(dCHK,x) is dCHK raised to the power x

   This fit was done in pre-flight calibration.
*/
extern double smsgxssdtemp();

/** smsgmaetempsc -- get MASS AE temperature (spacecraft thermistor) in
   degrees Celcius.  This routine reads CHK2 (via smsgchk(7,18))
   and converts it to a temperature through a polynomial equation.  See
   smsgdtempsc. */
extern double smsgmaetempsc();

/** smsgmaetemp -- get MASS AE temperature in
   degrees Celcius.  This routine reads CHK39 (via smsgchk(131,17))
   and converts it to a temperature through a polynomial equation.  See
   smsgxssdtemp. */
extern double smsgmaetemp();

/** smsgtssdtempsc -- get STICS SSD temperature (spacecraft thermistor)
   in degrees Celcius.  This routine reads CHK3 (via
   smsgchk(11,17)) and converts it to a temperature through a
   polynomial fit.  See smsgxaetempsc. */
extern double smsgtssdtempsc();

/** smsgtaetempsc -- get STICS AE temperature (spacecraft thermistor)
   in degrees Celcius.  This routine reads CHK4 (via
   smsgchk(13,18)) and converts it to a temperature through a
   polynomial fit.  See smsgxaetempsc. */
extern double smsgtaetempsc();

/** smsgtaetemp -- get STICS AE temperature
   in degrees Celcius.  This routine reads CHK60 (via
   smsgchk(201,17)) and converts it to a temperature through a
   polynomial fit.  See smsgxssdtemp. */
extern double smsgtaetemp();

/** smsgtssdtemp -- get STICS SSD temperature
   in degrees Celcius.  This routine reads CHK61 (via
   smsgchk(203,18)) and converts it to a temperature through a
   polynomial fit.  See smsgxssdtemp. */
extern double smsgtssdtemp();

//@}

/* libsms-h2i-end */

/********************************************/
/* prototypes for libsms internal functions */
/********************************************/

//@{ \name Functions - libsms internal functions

/** Get info from File Label Record of SMS data */
int getFLR(unsigned char *);
/** Get info from Data Record Header of SMS data */
int getDRH(unsigned char *);
int getXDB(BYTE [], int *);
int structTest(BYTE []);
EDB fillStructEDB(BYTE [], EDB_H_DC *, short);
EDB_R_H fillStructEDB_R_H(BYTE [], EDB_H_DC *, short);
int fixTcore(int);
EDB_H_DC decodeEDBheader(BYTE []);
HDB decodeHDB(BYTE []);
TPHA decodeTPHA(int, int);
XPHA decodeXPHA(int, int);
MPHA decodeMPHA(int, int);
/** Reads a data record from the open file, performs some basic checks on the read and gets DRH decoded */
int readRecord(BYTE [250][42], int *);
int fixReadoutDelay(int);
/** Initialize global variables */
int libsmsInit();
unsigned getBits(unsigned byte, int lobit,int hibit); /* also smsGetBits */
int checkEDBseq();
float fTemperature( unsigned char, int);

//@}

/***************************************************/
/* ALL external variables used by libsms functions */
/***************************************************/

FILE *pInfile; /**< pointer to input file */
FLR flr; /**< FLR structure */
DRH drh; /**< Data Record Header structure for current record */
CYCLE cycle; /**< current cycle */

/* initialized in libsmsInit */
int gDbgLvl; /**< global debug level -- set with smssdbg() */
int gTrace; /**< trace flag -- set with smsstrace() */
int gfIncCycOver; /**< incomplete cycle override; T ==> keep incomplete cycles*/
int gfQualOver; /**< quality override; T ==> keep cycles with bad EDB(s) */
char gVersion[12]; /**< current version of libsms; passed in by make */

/* initialized in smsReadCycle */
int ncycle; /**< number of acceptable cycles found this day */

int isHigh; /**< to keep track of whether the current cycle is in high or low bit rate mode 0=low, 1=high */
