#! /usr/bin/perl

##-I/home/winddata/sw/libsms
# Filename tpha.pl
#
# Description: Extract WIND/STICS PHA items and output in columnar format.
# Created by: Jim Raines, 18Jan00
#
# This program is controlled by CVS.
# $Id: tpha.pl,v 1.1 2005/12/01 17:35:44 jfeeman Exp $
#
# Major Modification History
#   Changed to use highest version of data file.  J. Raines, 2May00.
#
use libsms;
use Getopt::Long;

##############
# parameters #
##############

##$LV1DIR = '/home/winddata/LV1';
$LV1DIR = '/shrg1/wind/LV1';

##############
# perl setup #
##############

# init. some flags
$fOnce = 0; # keeps smsDecommHDB from being run for each cycle

# define some stuff
$thisprog = "tpha";

# get command line options
GetOptions("help!","debug:i","trace:i");

# print banner
print <<EOF;
$thisprog: Extracts PHA data items from WIND/STICS and outputs in columnar format
revision \$Id: tpha.pl,v 1.1 2005/12/01 17:35:44 jfeeman Exp $ \n

EOF
# print usage statement and exit
if ($opt_help){
  print <<EOF;

usage: $thisprog yyyymmdd [optional args]
  Processes WIND/SMS data file for yyyymmdd.

  optional args:
  --debug=i          set libsms debug level to i (see libsms.html)
  --trace=i          set libsms trace to i (0 ==> off; 1 ==> on)  
                     (Outputs messages at each stage; see libsms.html.)
  --help             prints this message
EOF
  exit(0);
}

# set debug and trace levels from options if present or to zero otherwise
if (!$opt_debug) {
  $opt_debug = 0;
}
if (!$opt_trace){
  $opt_trace = 0;
}

# set date based from 1st argument (or use default)
if (@ARGV >= 1) {
  $Date = $ARGV[0];
  $Date =~ /(\d{4})(\d{2})(\d{2})/;  # split out year
  $year = $1;
}
else {
  print "$thisprog: year and date required; use --help option for syntax\n";
  exit(1);
}

# Find highest version of data file
## prototypical filename: wi_lz_sms_20000229_v01.dat
$base = "$LV1DIR/$year/wi_lz_sms_".$Date."_v";
$ext = ".dat";
@Files = glob("$base*.dat");  # returns all versions of file
$File = $Files[-1]; # takes last element of list which is highest version
print "$thisprog: will read from $File\n";

# initialize output file
$outfile = "pha$Date.tph";
open(OUT,">".$outfile) or die "Cannot open $outfile.";

print "$thisprog: will output to $outfile\n";


######################
# begin libsms stuff #
######################

#print "$File\n";
$result = libsms::smsOpenFile($File);

# print output file headers -- note: must do after open b/c to init smsgver
print OUT "# PHA items from WIND/STICS, file $File\n";
print OUT "# generated by $thisprog.pl on ";
print OUT scalar localtime;
printf OUT (", libsms v. %s\n", libsms::smsgver()); 
print OUT "# The columns are in the following order:\n";
print OUT "# sci-rec bitr year doy hh mm ss dvs   e/q stopid st/rng Ed sector ";
print OUT "ssdId Td start range    m/q   mass  Nm   Nq\n";

## set debug level and trace
$result = libsms::smssetdbg($opt_debug);
print "$thisprog: setting smssetdbg=$result\n";
$result = libsms::smssettrace($opt_trace);
print "$thisprog: setting smssettrace=$result\n";

## read cycle
$ncycle = 0;
while ( ($result = libsms::smsReadCycle()) == 0) { # fix: 0 -> SMSSUCCESS
  $ncycle++;

  # get time string for cycle
  printf("%s: Cycle[%3.3d] time is %s\n",$thisprog,$ncycle,
	 libsms::smsgtimes()); 
  
  # write info commuted over many HDBs into memory for later retrieval
  if (!$fOnce) {
    #libsms::smsDecommHDB();
    $fOnce = 1;
  }

  for ($nedb=0; $nedb < 60; $nedb++) {
    # EDB header info
    #printf("%s: EDB[%2.2d] time is %s",$thisprog,$nedb,
    #   smsgtimes()); # get time string for cycle
    
    if (libsms::smsgtnpha($nedb) >= 1){
     
      #########################
      # print STICS PHA items #
      #########################

      # separate hours, minutes and seconds to make it easier to read in
      libsms::smsghms() =~ /(\d{2}):(\d{2}):(\d{2})/;
      $hour = $1;
      $min = $2;
      $sec = $3;

      # libsms works only for low bitrate anyway
      $bitrate = 0; # (0 ==> low)

      # Cham-like output to compare
      for ($npha = 0; $npha < libsms::smsgtnpha($nedb); $npha++){
	$fill = 0;	# filler for items I don't think we need
	$strtrng = libsms::smsgtstart($nedb,$npha)*3 + 
	  libsms::smsgtrange($nedb,$npha);
	
	printf OUT
	  ("    %5.5d %1d    %4.4d %3.3d %2.2d %2.2d %2.2d %2.2d %6.2f     %2.2d   %2.2d   %2.2d   %2.2d     %1.1d  %3.3d    %2.2d   %2.2d  %6.2f  %5.1f  %2.2d  %3.3d\n",
	#  ("%d %d %d %d %s %d %f %d %d %d %d %d %d %f %f %d %d\n",
	   libsms::smsgscirec(),$bitrate,libsms::smsgyear(),libsms::smsgdoy(),
	   $hour,$min,$sec,libsms::smsgtdvs($nedb),
	   libsms::smsgteoq($nedb,$npha),libsms::smsgtstopid($nedb,$npha),
	   $strtrng,libsms::smsgted($nedb,$npha),
	   libsms::smsgtsector($nedb,$npha),libsms::smsgtssdid($nedb,$npha),
	   libsms::smsgttofd($nedb,$npha), libsms::smsgtstart($nedb,$npha),
	   libsms::smsgtrange($nedb,$npha),
	   libsms::smsgtmoq($nedb, $npha),libsms::smsgtmass($nedb,$npha),
	   libsms::smsgtnm($nedb, $npha),libsms::smsgtnq($nedb,$npha),$fill);

      } # loop over PHA
    } 
  } # loop of EDBs
} # loop over cycles

# tidy up and exit
libsms::smsCloseFile();
close OUT;
